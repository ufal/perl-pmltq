<?xml version="1.0" encoding="utf-8"?>
<article lang="en">
  <articleinfo>
    <author>
      <firstname>Petr</firstname>
      <surname>Pajas</surname>
    </author>
    <title>PML Tree Query</title>
    <subtitle>Version 0.5.1 (alpha)</subtitle>
  </articleinfo>
  <section>
    <title>Introduction</title>
    <para>
      PML Tree Query (PML-TQ) is a query language and search engine
      targeted for querying over multi-layer annotated treebanks
      stored in the PML data format. As such, it can be used to
      perform queries over dependency or constituency treebanks,
      parallel treebanks, or other kinds of richly structured and/or
      multi-layered types of annotation.
    </para>
    <para>
      The query language is declarative and offers both textual and
      graphical representation of queries.  Currently, there are two
      implementations of the query engine, one is based on relational
      database (Oracle) and the other is Perl-based (using the TrEd
      toolkit), and three user interfaces: a full-featured graphical
      user interface built in TrEd, a very raw WEB-based interface
      with text-only output, and command-line interface.
    </para>
    <para>
      TODO: Purpose, features, and comparison with other query languages and engines
      (XPath, NetGraph, TGrep2, Nite, LPath+)
    </para>
    <para>Main features:</para>
    <orderedlist>
      <listitem>
	<para>queries can span over all layers of annotation (including annotation dictionaries)</para>
      </listitem>
      <listitem>
	<para>offers graphical query representation with relations between nodes depicted as arrows</para>
      </listitem>
      <listitem>
	<para>GUI interface built into TrEd</para>
      </listitem>
      <listitem>
	<para>understands PML data model (no conversion, no information loss)</para>
      </listitem>
      <listitem>
	<para>allows arbitrary logical constraints</para>
      </listitem>
      <listitem>
	<para>supports output filters (generate custom text output, compute statistics, ...)</para>
      </listitem>
    </orderedlist>
  </section>
  <section>
    <title>Basic concepts</title>
    <para>
      A <firstterm>PML-TQ query</firstterm>
      consists of a <firstterm>body</firstterm> that selects
      nodes from the treebank and an optional
      list of <firstterm>output filters</firstterm> that
      are used to
      extract data from the matching nodes,
      compute statistics, and/or format and post-process the results
      of a query.
    </para>
    <para>
      The body of a PML-TQ query defines of
      restrictions on properties 
      of one or more nodes from the treebank
      and describes their mutual relationships
      (e.g. the topological configuration in
      the tree structure).
      An ordered tuple of nodes in the treebank <firstterm>matches</firstterm>
      the query if each of them
      satisfies the corresponding constraints
      on its properties and
      the relationships between the nodes 
      are as declared in the query.
      Such a tuple of nodes from the treebank is called
      a <firstterm>match</firstterm>
      and there can be zero, one, or more
      distinct matches of the query in the treebank
      (two matches are distinct if they differ in
      at least one node).
    </para>
    <para>
      A PML-TQ query can 
      optionally define a list of <firstterm>output filters</firstterm> that
      can extract data from the matching nodes,
      compute statistics, and further format and post-process the results
      of a query.
    </para>
    <para>
      The body of a PML-TQ query is formed by one or more <firstterm>node selectors</firstterm>,
      which can nest further node selectors.
      A node selector represents a 
      node the treebank and two different selectors represent
      two different nodes (except for subqueries as described later).
      It specifies the type of the node (the nodes in the treebank annotation can be typed
      or the query can refer to several annotation layers with different types of nodes),
      a symbolic name for the selector (variable),
      and a set of constraints on the node.
      There are several types
      of constraints:
      <itemizedlist>
	<listitem><para>predicates</para></listitem>
	<listitem>
	  <para>nested node selectors</para>
	</listitem>
	<listitem>
	  <para>references</para>
	</listitem>
	<listitem>
	  <para>subqueries
	  </para>
	  <para>boolean combinations of predicates, references, and subqueries</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      <firstterm>Predicate constraints</firstterm> assert equality, inequality, or regular expression match
      between values computed from terms. An atomic term is a
      constant (integer, float, or character string),
      or an attribute of a node matched by the query.
      A term is either an atomic term or a term obtained from other terms
      using arithmetical (<literal>+, *, -, div, mod</literal>) or string 
      (concatenation <literal>&amp;</literal> ) operators,
      or functions.
    </para>
    <para>
      A <firstterm>nested node selector</firstterm>
      represents a node and
      specifies the relationship between
      this node and the
      node among whose constraints it is declared.
      The relationship specification can be omitted
      in which case it defaults to <literal>child</literal>,
      meaning that the nested selector is matched by a child
      of the node matching the containing selector.
      Thus, nesting of selectors can naturally follow
      the topology of the matching tree.
      Nested selectors can be named
      using a variable and referred to from other node selectors.
    </para>
    <para>
      A <firstterm>reference</firstterm> is a declaration of the relationship
      between the nodes corresponding to the current selector and 
      some other named selector.
    </para>
    <para>
      Finally, a <firstterm>subquery</firstterm> is a 
      selector
      with specification of restrictions on number of occurrences.
      The nodes declared within a subquery
      are not part of the resulting match,
      and nodes outside the subquery cannot
      refer to nodes within the subquery;
      however, nodes in the subquery may refer
      to the nodes in its outer scope (except, of course,
      to nodes within another subquery).
      A subquery constraint is verified as follows:
      for each match of the selector
      among whose constraints the subquery occurs,
      all matches of the subquery are located
      (these may coincide with nodes
      matching the outside query).
      The number of distinct nodes matching the top node of the subquery
      are counted and this number is compared with the restrictions
      on number of occurrences.
      The constraint is satisfied if and only if
      these restrictions are met.
    </para>
    <para>A constraint can also be a boolean combination of other constraints,
    but if a node selector occurs in a boolean combination
    it is considered to be a subquery with at least one occurrence.
    </para>
    <para>
      A PML-TQ query can be represented graphically as 
      one or more trees whose nodes
      represent the node selectors
      and whose edges represent declaration and subquery nesting.
      In this sense we may sometimes refer to selectors
      as <firstterm>query nodes</firstterm>
      and to the query as <firstterm>query graph</firstterm>
      or <firstterm>query tree</firstterm> (a technical root
      can be added above all the trees so that the forest becomes a single tree).
      The edges can be typed (colored) to represent
      the relationship between the corresponding nodes.
      Additionally, relationships between non-nested nodes 
      can be represented by additional layer of edges in the graph
      that may arbitrarily cross the basic tree structure of the query.
    </para>
<!--
    <glossary>
      <glossentry>
	<glossterm>
	  node selector (query node)
	  matching node
	  attribute
	  node type
	  relation
	  variable
	  subquery
	  reference
	  output filter
	</glossterm>
	<glossdef>
	  <para></para>
	</glossdef>
      </glossentry>
    </glossary>
-->
  </section>
  <section>
    <title>Tutorial</title>
    <para>
      Step by step tutorial (TrEd based).
    </para>
    <para>
      The purpose of this tutorial is to show how to create and run
      queries. It gradually passes from very simple to complex
      queries. The examples are queries over the Prague Dependency
      Treebank 2.0 and we always show both how to write the query in
      textual form as well as how to build and run the query graphically in
      the tree editor TrEd.
    </para>
    <bridgehead>Getting started</bridgehead>
    <para>
      To start experimenting with the toolkit,
      start TrEd and press <keycombo><keysym>Ctrl</keysym><keysym>F3</keysym></keycombo>
      or select <menuchoice>
      <guimenu>Macros</guimenu>
      <guisubmenu>TredMacro</guisubmenu>
      <guimenuitem>New Tree Query</guimenuitem>
    </menuchoice>.
    <mediaobject>
      <imageobject role="html"><imagedata align="center" fileref="tred_select_search_s.png" format="PNG"/></imageobject>
    </mediaobject>
    Choose <guilabel>Treebank (server)</guilabel>
    and then select <guilabel>CREATE NEW CONNECTION</guilabel>.
    Fill the connection form as follows:
    for <literal>id</literal> use any ID you like to name this connection configuration
    with, e.g. PDT-server (the name must start with a letter, must not contain spaces nor any special characters).
    As an URL, fill the search engine URL (e.g. <literal>http://mysearchserver.org:8082</literal>
    where <replaceable>mysearchserver.org</replaceable> is the hostname or IP address of your
    PML-TQ search server and <replaceable>8082</replaceable> is the port the search service listens on.
    Fill in <literal>username</literal> and <literal>password</literal> for the search service
    that you have received from the service administrator. When done, confirm with <literal>OK</literal>.
    </para>
    <para>
      A window with an empty query tree is displayed by TrEd:
      <mediaobject>
	<imageobject role="html"><imagedata align="center" fileref="tred_empty_query_s.png" format="PNG"/></imageobject>
      </mediaobject>
    </para>
    <bridgehead>A simple query</bridgehead>
    <para>
      Now we may create our first simple query.
      We shall search for all nodes of the type <literal>t-node</literal>
      (tectogrammatical nodes in PDT~2.0) that
      whose attribute <literal>functor</literal>
      equals to <literal>DPHR</literal>.
      The query can be created in several ways:
    </para>
    <itemizedlist>
      <listitem>
	<para>Method 1: Press
	<keysym>Insert</keysym> or 
	<guibutton>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="pmltq_icons/add_node.png" contentdepth="10pt" format="PNG"/></imageobject>
	    <textobject><phrase>Add node</phrase></textobject>
	  </inlinemediaobject>
	</guibutton>
	on the toolbar to create a new selector,
	choose <literal>t-node</literal> from
	the offered list of node types and confirm
	with <guibutton>OK</guibutton>.
	</para>
	<para>
	  Then press <keysym>=</keysym>
	  or 
	<guibutton>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="pmltq_icons/test_equality.png" contentdepth="10pt" format="PNG"/></imageobject>
	    <textobject><phrase>Equality</phrase></textobject>
	  </inlinemediaobject>
	</guibutton>
	to create a new atomic constraint,
	and fill <literal>functor</literal>
	as <literal>a</literal>
	and <literal>"DPHR"</literal>
	as <literal>b</literal> in the form
	(both the attribute name and its value can be
	selected from a list).
      <mediaobject>
	<imageobject role="html"><imagedata align="center" fileref="tred_new_equality_test_s.png" format="PNG"/></imageobject>
      </mediaobject>
	</para>
      </listitem>
      <listitem>
	<para>Method 2: Press <keysym>e</keysym> 
	or
	<guibutton>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="icons/edit_file.png" contentdepth="10pt" format="PNG"/></imageobject>
	    <textobject><phrase>Edit query</phrase></textobject>
	  </inlinemediaobject>
	</guibutton>
	to open the query text editor and type
	<programlisting>t-node [ functor='DPHR' ]</programlisting>
	into the text field.
	</para>
      </listitem>
      <listitem>
	<para>Method 3: Open the query text editor
	as above, but use helper buttons below the
	text field to build the text of the query:
	Press <guibutton>Type</guibutton>
	and select <literal>t-node</literal>,
	Press <guibutton>[ ]</guibutton>,
	put the cursor between the brackets by clicking
	there or by pressing the <keysym>left arrow</keysym> two times,
	press <guibutton>Attribute</guibutton> and select
	<literal>functor</literal>
	and finally press <guibutton>=</guibutton>
	and select <literal>"DPHR"</literal>.
	</para>
      </listitem>
    </itemizedlist>
    <para>The result in TrEd will look like this:</para>
    <mediaobject>
      <imageobject role="html"><imagedata align="center" fileref="tutorial_queries_1.png" format="PNG"/></imageobject>
    </mediaobject>
    <para>
      To start the search now,
      press <keysym>Space</keysym> 
	or
	<guibutton>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="pmltq_icons/search_filter.png" contentdepth="10pt" format="PNG"/></imageobject>
	    <textobject><phrase>Query</phrase></textobject>
	  </inlinemediaobject>
	</guibutton>
	or
	<guibutton>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="pmltq_icons/search.png" contentdepth="10pt" format="PNG"/></imageobject>
	    <textobject><phrase>Search</phrase></textobject>
	  </inlinemediaobject>
	</guibutton>.
	After a while, a window will pop up indicating
	whether some results have been found,
	and pressing <literal>Display</literal> will
	show the first result in a new view:
    <mediaobject>
      <imageobject role="html"><imagedata align="center" fileref="tred_first_result_s.png" format="PNG"/></imageobject>
    </mediaobject>
    To see the full sentence in the text field above the trees , click
    on the result view on the right.
    Next result can be displayed
    by pressing the key
    <keysym>n</keysym>
    or
    <guibutton>
      <inlinemediaobject>
	<imageobject role="html"><imagedata fileref="pmltq_icons/search_next.png" contentdepth="10pt" format="PNG"/></imageobject>
	<textobject><phrase>Next match</phrase></textobject>
      </inlinemediaobject>
    </guibutton>.
    </para>
    <note>
      <para>By default, the search engine returns
      up to 100 matches (in no particular order),
      which should be more than sufficient for viewing
      a few matching examples.
      This limit can be changed in the search engine configuration
      (displayed by pressing
    <keysym>C</keysym>
    or
    <guibutton>
      <inlinemediaobject>
	<imageobject role="html"><imagedata fileref="icons/configure.png" contentdepth="10pt" format="PNG"/></imageobject>
	<textobject><phrase>Configure</phrase></textobject>
      </inlinemediaobject>
    </guibutton>,
    but raising this limit may slow the search.
    We shall later see how to compute the number of all matches,
    using output filters.
      </para>
    </note>
    <para>Press
    <keysym>p</keysym>
    or
    <guibutton>
      <inlinemediaobject>
	<imageobject role="html"><imagedata fileref="pmltq_icons/search_previous.png" contentdepth="10pt" format="PNG"/></imageobject>
	<textobject><phrase>Previous match</phrase></textobject>
      </inlinemediaobject>
    </guibutton> 
    to go back to the previous match
    and press
    <guibutton>
      <inlinemediaobject>
	<imageobject role="html"><imagedata fileref="icons/apply.png" contentdepth="10pt" format="PNG"/></imageobject>
	<textobject><phrase>This match</phrase></textobject>
      </inlinemediaobject>
    </guibutton> 
    to return the current match to view.
    </para>
    <para>Note that the result view contains not only the matching
    tree but the complete document, so it is possible to see the tree
    preceding or following the currently matching tree
    by pressing
    <keysym>PageUp</keysym>/<guibutton>
    <inlinemediaobject>
	<imageobject role="html"><imagedata fileref="icons/1leftarrow.png" contentdepth="10pt" format="PNG"/></imageobject>
	<textobject><phrase>Previous Tree</phrase></textobject>
      </inlinemediaobject>
    </guibutton>
    or 
    <keysym>PageDown</keysym>/<guibutton>
      <inlinemediaobject>
	<imageobject role="html"><imagedata fileref="icons/1rightarrow.png" contentdepth="10pt" format="PNG"/></imageobject>
	<textobject><phrase>Next Tree</phrase></textobject>
      </inlinemediaobject>
    </guibutton>,
    respectively.
    </para>

    <bridgehead>A query with two nodes</bridgehead>
    <para>We shall now make the query more complex
    by adding another node to it.
    We shall ask for a t-node with
    functor "DPHR" that has a child
    (since DPHR t-nodes are often leaves,
    it may be interesting to see what children we get).
    </para>
    <para>
      To add a new child,
      select the only node in our query tree
      and press 
      <keysym>Insert</keysym> or 
      <guibutton>
	<inlinemediaobject>
	  <imageobject role="html"><imagedata fileref="pmltq_icons/add_node.png" contentdepth="10pt" format="PNG"/></imageobject>
	  <textobject><phrase>Add node</phrase></textobject>
	</inlinemediaobject>
      </guibutton>
      on the toolbar.
      Now a pop-up window shows
      asking for a type of relation
      the new node to the existing node.
      The default value is <literal>child</literal>.
      Since this is what we want, click
      <guibutton>OK</guibutton>.
      TrEd automatically assumes
      the new query node to be a selector
      for nodes of the type <literal>t-node</literal>,
      since, according to the
      PML schema of the tectogrammatical layer,
      a <literal>t-node</literal> can only have
      a <literal>t-node</literal> for its child;
      otherwise it would offer a list of nodes types
      to choose from.
    </para>
    <para>In text form, the query can be equivalently expressed as
    <programlisting>t-node [ functor='DPHR', t-node [ ] ]</programlisting>
    or
    <programlisting>t-node [ functor='DPHR', child t-node [ ] ]</programlisting>
    These forms use nesting of node selectors, the first form
    makes use of the fact that the default relation of a nested selector
    to the selector in which it is nested is <literal>child</literal>.
    </para>
    <para>
    The query can also be expressed without nesting, using names, either as
    <programlisting>t-node $a := [ functor='DPHR', child $b ];
t-node $b := [ ];</programlisting>
    or
    <programlisting>t-node $a := [ functor='DPHR' ];
t-node $b := [ parent $a ];</programlisting>
    naming the
    two nodes <literal>$a</literal> and <literal>$b</literal> and
    either indicating that <literal>$a</literal> has a child $b or
    that <literal>$b</literal> has a parent $a.
    </para>
    <bridgehead>Disjunctions, regular expressions and set enumerations</bridgehead>
    <para>We now extend our query expression
    to cover also t-nodes with functor <literal>CPHR</literal>.
    This can be done in three different ways:
    </para>
    <para>Using a disjunction:
    <programlisting>t-node [ (functor='DPHR' or functor='CPHR'), t-node [ ] ]</programlisting>
    Apart from editing the query, this can be created using the GUI e.g. in the following steps:
    <orderedlist>
      <listitem><para>Select the top query node (the one with the <literal>functor="DPHR"</literal> constraint</para></listitem>
      <listitem><para>Press 
      <keysym>h</keysym> or 
      <guibutton>
	<inlinemediaobject>
	  <imageobject role="html"><imagedata fileref="pmltq_icons/toggle_hide_subtree.png" contentdepth="10pt" format="PNG"/></imageobject>
	  <textobject><phrase>(Un)Expand</phrase></textobject>
	</inlinemediaobject>
      </guibutton>
      to expand the constraints to auxiliary nodes in the query tree.
      The result will look like this:
    </para>
    <mediaobject>
      <imageobject role="html"><imagedata align="center" fileref="tutorial_queries_1.png" format="PNG"/></imageobject>
    </mediaobject>
      </listitem>
      <listitem>
    <para>Select the auxiliary node representing the constraint <literal>functor="DPHR"</literal> and press
      <keysym>o</keysym> or 
      <guibutton>
	<inlinemediaobject>
	  <imageobject role="html"><imagedata fileref="pmltq_icons/or.png" contentdepth="10pt" format="PNG"/></imageobject>
	  <textobject><phrase>OR</phrase></textobject>
	</inlinemediaobject>
      </guibutton>
      to create an auxiliary <literal>OR</literal> node above it.
      </para></listitem>
      <listitem>
	<para>Select the <literal>OR</literal> node and press
      <keysym>=</keysym> or 
      <guibutton>
	<inlinemediaobject>
	  <imageobject role="html"><imagedata fileref="pmltq_icons/test_equality.png" contentdepth="10pt" format="PNG"/></imageobject>
	  <textobject><phrase>Equality</phrase></textobject>
	</inlinemediaobject>
      </guibutton>
      to create a new equality constraint
      and as above, fill <literal>functor</literal> as <literal>a</literal>
      and <literal>"CPHR"</literal> as <literal>b</literal> in the form.
      Alternatively, you can select the node
      <literal>functor="DPHR"</literal>, press
      <keysym>Ctrl+Insert</keysym> or 
      <guibutton>
	<inlinemediaobject>
	  <imageobject role="html"><imagedata fileref="icons/editcopy.png" contentdepth="10pt" format="PNG"/></imageobject>
	  <textobject><phrase>Copy</phrase></textobject>
	</inlinemediaobject>
      </guibutton>
      to copy it into the clipboard,
      then select the <literal>OR</literal> node
      and press <keysym>Shift+Insert</keysym> or 
      <guibutton>
	<inlinemediaobject>
	  <imageobject role="html"><imagedata fileref="icons/editpaste.png" contentdepth="10pt" format="PNG"/></imageobject>
	  <textobject><phrase>Paste</phrase></textobject>
	</inlinemediaobject>
      </guibutton>
      to paste it. The press <keysym>Enter</keysym> or double-click the node
      or just the word <literal>"DPHR"</literal> on one of the two nodes
      and change <literal>"DPHR"</literal> to <literal>"CPHR"</literal>.
	</para>
      </listitem>
      <listitem>
	<para>The result will look like this: 
    <mediaobject>
      <imageobject role="html"><imagedata align="center" fileref="tutorial_queries_2b.png" format="PNG"/></imageobject>
    <imageobject role="fo"><imagedata align="center" fileref="tutorial_queries_2b.pdf" format="PDF"/></imageobject></mediaobject>
    Selecting the top t-node and pressing <keysym>h</keysym> or
    <guibutton>
      <inlinemediaobject>
	<imageobject role="html"><imagedata fileref="pmltq_icons/toggle_hide_subtree.png" contentdepth="10pt" format="PNG"/></imageobject>
	<textobject><phrase>(Un)Expand</phrase></textobject>
      </inlinemediaobject>
    </guibutton>
    hides the auxiliary nodes, and gives this:
    <mediaobject>
      <imageobject role="html"><imagedata align="center" fileref="tutorial_queries_2c.png" format="PNG"/></imageobject>
    </mediaobject>
	</para>
      </listitem>
    </orderedlist>
    </para>
    <para>Using a regular expression:
    <programlisting>t-node [ functor ~ '[CD]PHR', t-node [ ] ]</programlisting>
    Symbol <literal>~</literal> (tilda) denotes a binary relation
    between two values that is true if and only if the value on the
    left interpreted as string matches the value on the right interpreted 
    as regular expression. The regular expression <literal>[CD]PHR</literal>
    is matched by any string containing either <literal>CPHR</literal> or <literal>DPHR</literal>
    as a substring. If, for example, <literal>XDPHR</literal> were a possible
    functor value, we would have to be more precise and rewrite the expression
    as
    <programlisting>t-node [ functor ~ "^[CD]PHR$", t-node [ ] ]</programlisting>
    Since <literal>^</literal> and <literal>$</literal>
    meta-characters are only matched by the start and end of a string,
    the value of <literal>functor</literal> now must be exactly <literal>CPHR</literal> or
    <literal>DPHR</literal>.
    </para>
    <para>
      Creating a regular expression test graphically in TrEd
      is similar to creating an equality test:
      either press <keysym>~</keysym> key or the
      <guibutton>
	<inlinemediaobject>
	  <imageobject role="html"><imagedata fileref="pmltq_icons/test_regexp.png" contentdepth="10pt" valign="middle" format="PNG"/></imageobject>
	  <textobject><phrase>RegExp</phrase></textobject>
	</inlinemediaobject>
      </guibutton> toolbar button.
      Do not forget to enclose the regular expression 
      (field labeled <literal>b</literal> in the dialog)
      into apostrophes or quotes
      since in the PML-TQ syntax it is just a literal string.
    </para>
    <para>Using a set enumeration:
    <programlisting>t-node [ functor in { "CPHR", "DPHR" }, t-node [ ] ]</programlisting>
    </para>
    <para>
      The relation <literal>in</literal>
      asserts that the value computed from the expression on the left
      equals to a value of some of the expressions 
      listed in the set enumeration on the right.
    </para>
    <para>
      The query text editor provides a button
      <guibutton>in { ... }</guibutton> that,
      for attributes with a fixed set of possible values,
      allows the enumeration to be created 
      by selecting the desired values from a list.
    </para>
    <bridgehead>TODO</bridgehead>
    <programlisting>
      ## Types of relations

      ## relations based on PML references
      
      #### reverted dependency
      t-node [ t-node [ a/lex.rf $a0 ],
               a/lex.rf $a1 ];
      a-node $a0 := [  a-node $a1 := [  ] ];

      #### Rcp without a grammatical coreference
      t-node 
      [ t_lemma = '#Rcp', !1x coref_gram.rf t-node [  ] ];

      ## PDT 2.0 specific relations: echild, eparent
   
      # 7.
      t-node [ echild t-node [ functor='DPHR' ], echild t-node [ functor='DPHR' ] ]


      #
      t-node $a := [ gram/sempos='v', 
                     ! echild t-node [ functor in { 'ACT','PAT','ADDR','ORIG','EFF' } ] 
		   ]

      #
       t-node [ 0x eparent t-node [ ] ]

      #
       t-node [ 0x eparent t-node [  ], 
                gram/sempos ~ '^n',
		functor !~ '^(PAR|DENOM)$' ];


      #### reverted e-dependency, exclude numbers
      a-node $ref0 := [ 
        m/tag !~ '^C' ,
        echild a-node $ref1 := [
	  m/tag !~ '^C' 
        ]
      ];
      t-node [ 
        a/lex.rf $ref1, 
        echild t-node [ a/lex.rf $ref0 ] 
      ];


      ## Subqueries

      # 3.
      t-node [ functor='DPHR', 2+x child t-node [ ] ]

      # 4.
      t-node [ functor='DPHR', 2+x descendant t-node [ ] ]

      # 5.
      t-node [ 2+x child t-node [ functor='DPHR' ] ]

      # 6.
      t-node [ 2+x echild t-node [ functor='DPHR' ] ]

      ## Functions

      t-node [ functor='DPHR', sons()&gt;1 ]

      ## Output filter

      t-node [ functor='DPHR' ]
      &gt;&gt; count()

      ## Simple output filters 

      t-node $n := [ functor='DPHR' ]
      &gt;&gt; max(sons($n))

      t-root $n := [ ]
      &gt;&gt; descendants($n)
      &gt;&gt; max(), min(), avg()

      ## Global aggregation with 'for' clause

      t-node $n := [ ]
      &gt;&gt; for $n.functor
         give $1, count()

      #### how many coref arrows can xstart in one t-node
      t-node $t := 
        [ coref_gram.rf t-node $c := [  ] ];
      &gt;&gt;  for $t give count()
      &gt;&gt; max()

      ## Ordering results

      t-node $n := [ ]
      &gt;&gt; for $n.functor
         give $1, count()
         sort by $2         
      
      ## Local aggregation with 'over'
      t-node $p := 
      [ echild t-node $c := [  ] ];
      &gt;&gt; $p.functor,$c.functor
      &gt;&gt; distinct $1,$2, count(over $1,$2), count(over $1)
      &gt;&gt; $1, $2, percnt($3 div $4,2)
         sort by $1,0-$3
      &gt;&gt; $1, $2, $3 &amp; '%'


      t-node $p := [ echild t-node $c :=  [  ] ];
      &gt;&gt;  for $p.functor,$c.functor
          give $1,$2,ratio(count() over $1)
          sort by $1,0-$3
      &gt;&gt; $1, $2, percnt($3,2)


    </programlisting>
  </section>
  <section>
    <title>Query Language</title>
    <para>
      Basic examples, syntax reference.
    </para>
    <section>
      <title>Brief PML-TQ syntax reference</title>
      <variablelist>
	<varlistentry>
	  <term>query</term>
	  <listitem>
	    <mediaobject id="rail_query">
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_query.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_query.pdf"/>
	      </imageobject>
	      <textobject role="syntax_diagram">
		<phrase><![CDATA[ query : (nodeSelector + ';') ( ';' (outputFilter*) )? ; ]]></phrase>
	      </textobject>
	    </mediaobject>
	    <para>PML-TQ query consists of one or more node selectors
	    separated by semicolon followed, optionally,
	    by a list of output filters.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>nodeSelector</term>
	  <listitem>
	    <mediaobject id="rail_nodeSelector">
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_nodeSelector.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_nodeSelector.pdf"/>
	      </imageobject>
	      <textobject role="syntax_diagram">
		<phrase><![CDATA[ nodeSelector : TYPE (variable ':=' )? \\ '[' constraints?  ']' ;
 ]]></phrase>
	      </textobject>
	    </mediaobject>

	      <para>Defines a node selector
	      that selects all nodes of type <replaceable>type</replaceable>
	      that satisfy given constraints. The selector
	      can optionally be associated with a variable for reference 
	      from other nodes.
	      </para>
	      <para>The intended way to translate the selector syntax
	      to English is to read 
	      <quote>node of type <replaceable>TYPE</replaceable> that has <replaceable>constraint1</replaceable>,
	        has <replaceable>constraint2</replaceable>, ... and has <replaceable>constraintN</replaceable></quote>
	      </para>
	      <para>
		A selector can be used as a constraint 
		of some other selector (i.e. it can be nested).
		If not preceded by a name of a relation,
		it selects among child nodes of the node matched
		by the containing selector;
		if preceded by a name of a relation, it selects
		among nodes that are in the particular relation
		to the node matched by the containing selector.
	      </para>
	      <para>
		For example, the query <literal>a-node $x := [ descendant a-node [ afun=$x.afun ]  ]  ]</literal>
		reads in English as
		<quote>
		  Find 
		  a node <literal>$x</literal> of type a-node
		  that has a descendant node
		  of type a-node that has <literal>afun</literal> equal to 
		  <literal>afun</literal> of <literal>$x</literal>.
		</quote>
		Over PDT 2.0 data it selects all analytical
		nodes whose subtree contains an analytical node with the same value
		of the attribute <literal>afun</literal> (the query returns 
		pairs of nodes with the described relationship).
	      </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>variable</term>
	  <listitem>
	    <mediaobject id="rail_variable">
	      
	      
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_variable.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_variable.pdf"/>
	      </imageobject><textobject role="syntax_diagram">
		<phrase><![CDATA[ variable : DOLLAR NAME ]]></phrase>
	      </textobject>
	    </mediaobject>
	    <para>Variables are used to name node selectors and refer to them
	    from other parts of the query. Variable starts
	    with a '$' (dollar) character and is followed by 
	    a NAME consisting of alphabetical character or underscore
	    and zero or more alphanumerical characters or underscores.
	    For example, <literal>$foo_02</literal> or <literal>$x</literal> are
	    valid variable names, while <literal>$23</literal> is not.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>optionalSelector</term>
	  <listitem>
	    <mediaobject id="rail_optionalSelector">
	      
	      
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_optionalSelector.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_optionalSelector.pdf"/>
	      </imageobject><textobject role="syntax_diagram">
		<phrase><![CDATA[ optionalSelector : '?' nodeSelector; ]]></phrase>
	      </textobject>
	    </mediaobject>

	      <para>
		If a nested node selector is preceded by a question mark,
		it is <firstterm>optional</firstterm>. This means, that if no node
		matches this selector, the selector is assumed to match the same node
		as its containing selector and all selectors or subqueries directly nested
		in the optional selector are then evaluated as
		if they were nested in the containing selector.
		For example, <literal>a-node $a := [ afun='Sb', ? a-node $b:= [ afun='AuxC', $c := [ afun='Obj']  ]  ]</literal>
		with $b optional,
		matches either a descending chain of three a-nodes 
		'Sb-&gt;AuxC-&gt;Obj' 
		(the optional selector $b matching the middle node)
		or just the pair
		'Sb-&gt;Obj', in which case both $a and $b are identified with the 'Sb'
		(the constraint <literal>afun='AuxC'</literal>) on $b is disregarded),
		but it does <emphasis>not</emphasis>, for instance, match a descending chain 'Sb-&gt;ExD-&gt;Obj'.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>subquery</term>
	    <listitem>
	      <mediaobject id="rail_subquery">
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_subquery.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_subquery.pdf"/>
	      </imageobject><textobject role="syntax_diagram">
		<phrase><![CDATA[ subquery : occurrences 'x' RELATION? nodeSelector;
occurrences : ( NUMBER | NUMBER '+' | NUMBER '-' | NUMBER '..' NUMBER ) + '|';
 ]]></phrase>
	      </textobject>
	    </mediaobject>
	      <para>Subquery is a subtree in the query tree that
	      specifies number of occurrences. For example,
	      <literal>3x</literal> specifies that the subtree must
	      match <emphasis>exactly</emphasis> three times,
	      <literal>3+x</literal> specifies that the subtree must
	      match <emphasis>at least</emphasis> three times,
	      <literal>3-x</literal> specifies that the subtree must
	      match <emphasis>at most</emphasis> three times and
	      <literal>3-10x</literal> specifies that the subtree must
	      match <emphasis>at least</emphasis> three times but at
	      most ten times.
	      </para>
	      <note><para>Node selectors belonging to a subquery cannot be
	      referred to by name from outside the subquery.</para></note>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>constraints</term>
	    
	    <listitem><mediaobject id="rail_constraints">
	      
	      
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_constraints.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_constraints.pdf"/>
	      </imageobject><textobject role="syntax_diagram">
		<phrase><![CDATA[ constraints : constraint + ',';]]></phrase>
	      </textobject>
	    </mediaobject>

	    <para>One or more constraints.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>constraint</term>
	    
	    <listitem><mediaobject id="rail_constraint">
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_constraint.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_constraint.pdf"/>
	      </imageobject><textobject role="syntax_diagram">
		<phrase><![CDATA[ constraint : ((predicate | RELATION? nodeSelector | RELATION variable | subquery |  '(' constraint ')' | '!' constraint ) + ('and' | 'or' )) ;
 ]]></phrase>
	      </textobject>
	    </mediaobject>
<para>
	      A constraint is either a 
	    binary test predicate
	    (<literal>=</literal>, 
	    <literal>!=</literal>
	    <literal>~</literal>, 
	    <literal>!~</literal>, 
	    <literal>&lt;</literal>
	    <literal>&lt;=</literal>
	    <literal>&gt;</literal> etc.) on
	    expressions (terms),
	    or a node selector or subquery,
	    or a reference to a named node selector
	    (indicating that a node matched by referred 
	    selector must be in the corresponding relation to the
	    node matched by the current selector)
	    or a logical combination of any of these.
	    However, a node selector used in a complex logical expression is
	    treated as a subquery with at least one occurrence.
	    </para>
	    <para>The intended way of reading a constraint aloud in English
	    in the context of a node selector is to precede it with
	    the word <quote>has</quote>.
	    </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>predicate</term>
	    
	    <listitem><mediaobject id="rail_predicate">
	      
	      
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_predicate.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_predicate.pdf"/>
	      </imageobject><textobject role="syntax_diagram">
		<phrase><![CDATA[ predicate : binaryComparison | setPredicate;
		binaryComparison : expression ( ('!'? ('=' | 'TILDA' | 'TILDASTAR' )) | '<' | '>' | '<=' | '>=') expression  ;
		setPredicate : (expression '!'? 'in' 'LEFTBRACE' (expression +',') 'RIGHTBRACE') ; ]]></phrase>
	      </textobject>
	    </mediaobject>
	      <para>
		A predicate is either a binary comparison of two expressions (terms) or a set membership predicate
		applied to a term and a set specified as an enumeration of other terms.
	      </para>
	      <para>
		The binary comparison consists of two expressions 
		and a binary relation. 
		The relations <literal>~</literal> and
		<literal>~*</literal> perform 
		case-sensitive and case-insensitive
		regular expression
		matching, respectively. The
		expression on the right must evaluate
		to a regular expression. For example
		<literal>afun ~ '^(Sb|Aux.*)$'</literal>
		is true if the value of the attribute
		<literal>afun</literal> of the current node selector
		either equals to the string <literal>Sb</literal> or
		starts with the string <literal>Aux</literal>.
	      </para>
	      <para>
		Set predicate 
		consists of a expression,
		the operator <literal>in</literal>
		and a comma-separated list of expressions
		enclosed in braces. It
		is true
		if the value computed from the expression on the left
		equals some of the values computed from the expressions
		on the right of the operator.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>expression</term>
	    
	    <listitem><mediaobject id="rail_expression">
	      
	      
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_expression.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_expression.pdf"/>
	      </imageobject><textobject role="syntax_diagram">
		<phrase><![CDATA[ expression : (literal | attributePath | function | '(' expression ')') + ('+' | '-' | '*' | 'div' | 'mod' | AMP)  ; ]]></phrase>
	      </textobject>
	    </mediaobject>

	      <para>
		Expressions are either literals (strings, integer of
		floating point numbers), 
		attribute paths,
		or functions, or any
		combination of these obtain by application of the
		binary string-concatenation operator ('&amp;') or the
		usual arithmetical operations for addition ('+'),
		subtraction ('-'), multiplication ('*'), division
		('div') and modulo ('mod'). Brackets can be used in the usual manner
		for grouping sub-expressions.
	      </para>
	      <para>For example, <literal>afun &amp; "." &amp; substr(m/tag,0,2)</literal>
	      is an expression returning a concatenation of the value of the attribute <literal>afun</literal>,
	      a dot and the first two characters from the value of the attribute <literal>m/tag</literal>.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>literal</term>
	    <listitem><mediaobject id="rail_literal">
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_literal.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_literal.pdf"/>
	      </imageobject><textobject role="syntax_diagram">
		<phrase><![CDATA[ literal : NUMBER | '"' STRING '"' | "'" STRING "'" ; ]]></phrase>
	      </textobject>
	    </mediaobject>

	      <para>A literal is either a number in the decimal
	      notation (integer or floating point,
	      e.g. <literal>231</literal> or
	      <literal>-1.0032</literal>) or a string of characters
	      enclosed in either <literal>"</literal> or
	      <literal>'</literal>.  Backslash character
	      <literal>\</literal> can be used as an escape character,
	      for example to insert a quote or apostrophe.
	      </para>
	      <para>
		For example: both <literal>"Peter's"</literal> and
	      <literal>'Peter\'s'</literal> both represent the literal
	      string <literal>Peter's</literal> and
	      both
	      <literal>'\\\"\'\n\r'</literal> and
	      <literal>"\\\"\'\n\r"</literal> represent
	      the literal five-character string <literal>\"'nr</literal>.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>attributePath</term>
	    <listitem><mediaobject id="rail_attributePath">
	      
	      
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_attributePath.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_attributePath.pdf"/>
	      </imageobject><textobject role="syntax_diagram">
		<phrase><![CDATA[ attributePath : '*'? (variable '.' )? (XMLNAME | '[]' | index | elementIndex ) + '/' ;
 index : '[' NUMBER ']';
 elementIndex : XMLNAME index | index XMLNAME; ]]></phrase>
	      </textobject>
	    </mediaobject>
	    <para>
	      An attribute path refers to
	      a value of an attribute of a treebank node
	      matched by a certain selector.
	      If the path starts with a variable followed by
	      a '.' (dot) character, then the it refers
	      to an attribute of the node matched by the
	      selector associated with the variable.
	      Otherwise it refers to the node matched
	      by the current selector (i.e.
	      the one within whose constraints
	      it occurs).
	    </para>
	    <para>
	      In the simplest form,
	      attribute path is just a name of an attribute,
	      e.g. <literal>functor</literal>.
	      However, some node attributes may have complex
	      values, i.e. structures with attributes of their own.
	      In such case one forms a slash-delimited attribute
	      path leading from the node
	      to some nested atomic value.
	      Each component of the path (step)
	      is either a
	    </para>
	      <variablelist>
		<varlistentry>
		  <term>name</term>
		  <listitem>
		    <para>specifying a member in a structure or any element of the given name in a sequence</para>
		  </listitem>
		</varlistentry>
		<varlistentry>
		  <term>the string <literal>'[]'</literal></term>
		  <listitem>
		    <para>used for obtaining the content of a container</para>
		  </listitem>
		</varlistentry>
		<varlistentry>
		  <term>index (<literal>[<replaceable>n</replaceable>]</literal>)</term>
		  <listitem>
		    <para>specifying <replaceable>n</replaceable>-th element in an ordered list</para>
		  </listitem>
		</varlistentry>
		<varlistentry>
		  <term>name followed by an index (<literal><replaceable>foo</replaceable>[<replaceable>n</replaceable>]</literal>)</term>
		  <listitem>
		    <para>specifying <replaceable>n</replaceable>-th element of a given name (<literal>foo</literal>)
		    in a sequence
		    </para>
		  </listitem>
		</varlistentry>
		<varlistentry>
		  <term>name preceded by an index (<literal>[<replaceable>n</replaceable>]<replaceable>foo</replaceable></literal>)</term>
		  <listitem>
		    <para>specifying <replaceable>n</replaceable>-th element in a sequence
		    and asserting that the <replaceable>n</replaceable>-th element name is as given (<literal>foo</literal>)
		    </para>
		  </listitem>
		</varlistentry>
	      </variablelist>
	      <para>
		If a partial attribute path returns an object of a
		list type, the next step in the path can either be an
		index or can be omitted (in which case any list member
		matches); if it returns a sequence, the next step must be
		an element name optionally followed or preceded by an
		index. If it is a structure or container, the next
		step must be a name of an attribute;  if it returns an
		alternative or an unordered list, the next step must
		be a valid step for the members of the alternative/list;
		if it returns an atomic value, there must be no further step.
	      </para>
	      <para>
	      For example
	      <literal>gram/sempos</literal> selects
	      the attribute <literal>sempos</literal>
	      of a structure stored in the attribute
	      <literal>gram</literal> of the node
	      matched by the current selector.
	      The path
	      <literal>a/[1]/b</literal> may select
	      an attribute b of a structure
	      stored in the 2nd member
	      of an ordered list stored in the attribute <literal>a</literal>;
	      the path <literal>a/b</literal> selects
	      the attribute b of any member of the list <literal>a</literal>.
	    </para>
	    <para>
	      If some part of an attribute path leads to an alternative, list, or sequence,
	      the path may match multiple values.
	      Assume <replaceable>R</replaceable> is some predicate
	      containing such an attribute path
	      in some of its expressions.
	      If attribute path is preceded by the <literal>*</literal> character
	      (a primitive universal quantifier),
	      then the predicate is true if and only if it is
	      true for every value matched by the attribute path.
	      If attribute path is not preceded by <literal>*</literal>,
	      then 
	      an existential quantifier is assumed: the predicate is true if and only if there
	      exists a value matched by the attribute path
	      for which the predicate is true.
	      If the predicate contains more such attribute paths,
	      the quantifiers (universal and implicit existential)
	      are applied in the same order in which the attribute paths
	      occur in the predicate.
	      See <xref linkend="quantifiers"/>
	      for details.
	    </para>
	    <para>
	      Example:
	      <programlisting>a-node $p:= [ child a-node [ afun=$p.afun, afun~'^Aux' ] ]</programlisting>
	      The above query selects
	      a node its child node (both of type <literal>a-node</literal>)
	      that have the same value of the attribute
	      <literal>afun</literal>
	      and the value starts with the substring <literal>Aux</literal>.
	    </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>function</term>
	    <listitem><mediaobject id="rail_function">
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_function.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_function.pdf"/>
	      </imageobject><textobject role="syntax_diagram">
		<phrase><![CDATA[ function : FUNC '(' (expression + ',' ) ')' ; ]]></phrase>
	      </textobject>
	    </mediaobject>
	    <para>
	      Functions are written as function name followed by a comma-separated list of its arguments in brackets.
	      The functions currently supported by PML-TQ are listed in 
	      Section <xref linkend="functions"/>
	      :
	    </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>outputFilter</term>
	    <listitem><mediaobject id="rail_outputFilter">
	      
	      
	      <imageobject role="html">
		<imagedata format="PNG" fileref="rail_outputFilter.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata format="PDF" fileref="rail_outputFilter.pdf"/>
	      </imageobject><textobject role="syntax_diagram">
	      <phrase><![CDATA[ outputFilter : '>>' 
	                                     ('for' (columnExp + ','))? \\
					     ('give')? ('distinct')?
	                                     (columnExp + ',') \\
					     ('sort by'
					      (columnExp + ','))?; ]]></phrase>
	      </textobject>
	    </mediaobject>
	    <para>
	      An output filter transforms its input
	      (the result of the query
	      or the previous filter) into a table of values
	      whose columns are computed according to the filter specification.
	    </para>
	    <para>
	      The simplest form of a filter consists of a comma-separated list of
	      expressions that are used to compute values of the output columns from
	      the output of the body of the query or preceding filters.
	      For example:
	      <programlisting>&gt;&gt; $x.m/tag, depth($y)
&gt;&gt; 'found ' &amp; $1 &amp; ' at depth ' &amp; $2</programlisting>
	      defines two output filters: the first returns
	      a table whose rows correspond directly to
	      the matches of the query body. Its first column
	      contains the value of the attribute <literal>m/tag</literal>
	      of the node matched by the node selector <literal>$x</literal>
	      and the second column is the depth of the node
	      matched by the node selector <literal>$y</literal>.
	      The second output filter produces a table with just one
	      column 
	      with values of the form
	      <literal>found <replaceable>X</replaceable> at depth <replaceable>Y</replaceable></literal>,
	      where <replaceable>X</replaceable>
	      and <replaceable>Y</replaceable>
	      represent the two columns from the preceding filter.
	    </para>
	    <para>
	      In this case aggregation functions
	      that do not specify aggregation window
	      (using an <literal>over</literal> clause)
	      range over the whole input table.
	      For example,
	      <programlisting>&gt;&gt;min($1), max($1), avg($1)</programlisting>
	      is an output filter
	      that computes the minimum, maximum and
	      average form the values in the first column 
	      of the preceding filter
	      (and returns a table with three columns and a single row).
	    </para>
	    <para>
	    </para>
	    <para>
	      Each filter may be followed by
	      a <literal>sort by</literal> clause
	      which specifies the order of rows in the resulting table.
	      The clause is followed by a list of column expressions
	      that should refer to the columns of the table produced by this filter
	      and are used to compute the primary, secondary, tertiary,… etc.
	      sorting key.
	    </para>
	    <para>
	      The filter may optionally be preceded
	      by a <literal>for</literal> clause
	      that performs aggregation
	      of the input before computing
	      the output.
	      The <literal>for</literal> clause consists
	      of a set of column expressions
	      used to compute a vector of values from each input
	      row and aggregates all input rows
	      resulting in the same vector.
	      These vectors are used instead
	      of the original rows as input
	      for the rest of the filter,
	      but all aggregation functions
	      in the rest of the query
	      that do not specify aggregation window
	      (using an <literal>over</literal> clause)
	      range over the original input rows
	      aggregated by this particular vector.
	      For example:
	      <programlisting>a-node $n:= [ child a-node $b [] ];
&gt;&gt; for $m.afun, $b.afun
   give $1, $2, count()
   sort by $3</programlisting>
	      is a query whose body
	      returns pairs of a-nodes in the parent-child relation.
	      The output filter first computes 
	      a pair of values of the attribute <literal>afun</literal>
	      and then groups the results according
	      to this pair. The
	      <literal>$1, $2, count()</literal>
	      part of the filter returns
	      a table lists all distinct
	      pairs of <literal>afun</literal> values
	      and for each pair adds the number of
	      matches with this particular pair of <literal>afun</literal> values
	      computed using the aggregation function <literal>count()</literal>
	      that ranges over the group of aggregated matches.
	      The result is further sorted by the third column,
	      i.e. by the number of matches.
	    </para>
	    <para>
	      TODO: detail rules on using column references and aggregation functions
	    </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>columnExp</term>
	    <listitem><mediaobject id="rail_columnExp">
	      
	      
	      <imageobject role="html">
		<imagedata role="html" format="PNG" fileref="rail_columnExp.png"/>
	      </imageobject><imageobject role="fo">
		<imagedata width="100%" format="PDF" fileref="rail_columnExp.pdf"/>
	      </imageobject><textobject role="syntax_diagram">
	      <phrase><![CDATA[ columnExp : ((literal 
                                             | attributePath
	                                     | DOLLAR NUMBER
					     | FUNC '(' (columnExp + ',' ) ')' 
					     | AGGRFUNC '(' (columnExp + ',' ) 
					          ('over' (columnExp + ',' ) ('sort by' (columnExp + ',' ))?)?  ')' 
					     | '(' columnExp ')') + ('+' | '-' | '*' | 'div' | 'mod' | AMP))  ; ]]></phrase>
	      </textobject>
	    </mediaobject>
	    <para>
	      Column expressions are expressions that
	      further allow use of column references of the
	      form <literal>$<replaceable>N</replaceable></literal> where
	      <literal><replaceable>N</replaceable></literal>
	      is a positive integer 
	      and the use of aggregation functions
	      apart from normal functions.
	    </para>
	    <para>
	      The exact rules on usage of aggregation functions
	      and column references in column expressions
	      are detailed in the description of output filters above.
	    </para>
	    </listitem>
	  </varlistentry>	  
	</variablelist>
    </section>
  </section>
  <section id="functions">
      <title>Functions</title>
      <section>
	<title>Functions related to the tree structure</title>
      <variablelist>
	<varlistentry>
	  <term>name($var?)</term>
	  <listitem><para>Return the name of a node matched by the given selector
	  (assume current selector if used without an argument).
	  This function only makes sense if the node is an element of a PML sequence
	  (of trees or child nodes).</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>depth($var?)</term>
	  <listitem><para>Returns the depth in the tree (counting from 0)
	  of a node matched by a given selector. If no argument is given, the current selector is assumed.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>descendants($var?)</term>
	  <listitem><para>Returns the number of descendants
	  of the node matched by a given selector. If no argument is given, the current selector is assumed.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>lbrothers($var?)</term>
	  <listitem><para>Returns the number of left siblings
	  of the node matched by a given selector. If no argument is given, the current selector is assumed.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>rbrothers($var?)</term>
	  <listitem><para>Returns the number of right siblings
	  of the node matched by a given selector. If no argument is given, the current selector is assumed.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>sons($var?)</term>
	  <listitem><para>Returns the number of child nodes
	  of the node matched by a given selector. If no argument is given, the current selector is assumed.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>depth_first_order($var?)</term>
	  <listitem><para>Returns the depth-first order of the
	  node matched by the given selector (counting from 0). If no argument is given, the current selector is assumed.</para></listitem>
	</varlistentry>
      </variablelist>	
      </section>
      <section>
	<title>Functions related to corpus</title>
      <variablelist>
	<varlistentry>
	  <term>file($var?)</term>
	  <listitem><para>Returns the file name of a document in which the node matched by a given
	  (or current) selector occurrs.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>tree_no($var?)</term>
	  <listitem><para>Returns index of a tree in which a the node
	  matched by a given (or current) selector occurs,
	  i.e. the position of the tree in its document.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>address($var?)</term>
	  <listitem><para>Returns an URL uniquely determining the node
	  matched by a given (or current) selector.
	  The same value can be also computed using the following expression:
	  <literal>file($var) &amp; '##' &amp; tree_no($var) &amp; '.' &amp; depth_first_order($var)</literal>.</para></listitem>
	</varlistentry>
      </variablelist>
      </section>
      <section>
	<title>String functions</title>
      <variablelist>
	<varlistentry>
	  <term>length(string)</term>
	  <listitem><para>Returns the string length of a given expression.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>substr(string,offset,length?)</term>
	  <listitem><para>Returns a substring of a given string starting at at a given offset (first character
	  in the string has offset 0) and spanning for a given length or to the end of the string, 
	  if length is omitted or if the original string has less than offset+length characters.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>match(string,regexp,flags?)</term>
	  <listitem><para>Returns the first substring of a given string 
	  matching a given regular expression.
	  The optional third argument can be a string of flags modifying the behavior of the regular
	  expression matching procedure. The following flags are supported:
	</para>
	  <variablelist>
	    <varlistentry>
	      <term>i</term>
	      <listitem>
		<para>case insensitive match</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>c</term>
	      <listitem>
		<para>case sensitive match (default)</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>n</term>
	      <listitem>
		<para>allows the period (.) to match the newline character</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>m</term>
	      <listitem>
		<para>Treat string as multiple lines.
		That is, change "^" and "$" from matching the start or end of the string to matching the
		start or end of any line anywhere within the string.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>replace(string,substr,replacement)</term>
	  <listitem><para>Substitutes a given replacement for all (non-overlapping) occurrences of a given
	  substring in a given string and returns the result. For example, <literal>replace('banana ananas','ana','ANA')</literal>
	  returns <literal>bANAna ANAnas</literal>.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>substitute(string,regexp,replacement,flags?)</term>
	  <listitem><para>Substitutes a given replacement for the first or all (non-overlapping) substrings
	  matching a given regular expression in a given string and returns the result. 
	</para>
	<para>
	  The default behavior is to replace just the first matching substring. 
	  To replace all occurrences, use the flag 'g'. 
	</para>
	<para>
	  The replacement string may contain references to subexpressions 
	  of the matching regular expression (subexpressions are parts of the expressions 
	  enclosed in brackets). The string \N, where N is a digit from 1 to 9, is a reference
	  to the N-th subexpression (counting opening brackets from the left),
	  and is substituted in the result by the substring matched by that subexpression.
	  For example, if the regular expression was
	  <literal>a(b(c))(d)</literal>, then 
	  <literal>\1</literal>, <literal>\2</literal>,
	  and <literal>\3</literal> refer
	  to the subexpressions <literal>(b(c))</literal>,
	  <literal>(c)</literal>,
	  and <literal>(d)</literal>, respectively.
	</para>
	<para>Since backslash (<literal>\</literal>) is used
	to introduce subexpression references in the replacement string,
	literal backslash has to be written as <literal>\\</literal>.
	</para>
	<para>
	  The optional third argument is a string of flags modifying the behavior of the regular
	  expression matching procedure. Any of the flags described above for the
	  function <literal>match()</literal> can be used here, and additionally
	  <literal>substitute()</literal> supports the following flag:
	</para>
	  <variablelist>
	    <varlistentry>
	      <term>g</term>
	      <listitem>
		<para>global replace: replace all non-overlapping matches of a given regular expression</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  <para>
	    For example, <literal>substitute('banana ananas','([^n])a','\1@','g')</literal>
	    returns the string <literal>b@nana @nanas</literal>.
	  </para>
	  </listitem>
	</varlistentry>	
	<varlistentry>
	  <term>lower(string)</term>
	  <listitem><para>Returns lowercase version of a given expression.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>upper(string)</term>
	  <listitem><para>Returns uppercase version of a given expression.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>tr(string,characters_to_replace,replacement)</term>
	  <listitem><para>Replaces all occurences of given characters in a string with corresponding characters in the replacement set,
	  that is, replaces all occurrences of the Nth character from <replaceable>characters_to_replace</replaceable> with the Nth character
	  in the <replaceable>replacement</replaceable>. For example, <literal>tr('122-34','24','ab')</literal> returns the string 
	  <literal>1aa-b4</literal>.</para></listitem>
	</varlistentry>
      </variablelist>
      </section>
      <section>
	<title>Numerical functions</title>
	<variablelist>
	  <varlistentry>
	    <term>ceil(number)</term>
	    <listitem><para>Return the smallest integer value greater than or equal to a given numerical argument.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>floor(number)</term>
	    <listitem><para>Return the largest integer value less than or equal to the numerical argument.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>round(number,places?)</term>
	    <listitem><para>Returns a given number rounded to a specified number of decimal places (0 if the second argument is not specified).</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>trunc(number,places?)</term>
	    <listitem><para>Returns a number truncated to a certain number of decimal places (0 if second argument is not specified).</para></listitem>
	  </varlistentry>
	  <!--
	      <varlistentry>
	      <term>percnt(number,places?)</term>
	      <listitem><para>This is a convenience function, which returns
	      the same value as <literal>round(100*number,places)</literal>.</para></listitem>
	      </varlistentry>
	  -->
	</variablelist>
      </section>
      <section>
	<title>Aggregation functions</title>
	<para>
	  Aggregation functions can only be
	  used in output filters.
	  There are two ways
	  of using these functions:
	</para>
	<orderedlist>
	  <listitem>
	    <para><literal><replaceable>func</replaceable>(<replaceable>arguments...</replaceable>)</literal>.
	    If this form is used in the
	    <literal>give</literal> part of a
	    <literal>for ... give ...</literal>
	    clause, the function
	    computes its value by considering
	    only those input rows that
	    belong to the current aggregation
	    group.
	    If used outside a
	    <literal>for ... give ...</literal>
	    clause, the function
	    computes its value by considering
	    all input rows (i.e.
	    the rows returned by the preceding filter
	    or the body of the query).
	    </para>
	  </listitem>
	  <listitem>
	    <para><literal><replaceable>func</replaceable>(<replaceable>arguments...</replaceable> over <replaceable>colspec, ...</replaceable>)</literal>.
	    This form creates a temporary aggregation
	    of the current input according to given column
	    specifications following the <literal>over</literal> keyword
	    and computes the value by considering
	    input rows of the aggregation group
	    to which the current input row belongs.
	    Unlike <literal>for ... give ...</literal>,
	    this type of aggregation does not
	    propagate to the output, so the
	    filter still returns one output row for each input row,
	    rather than a row for each aggregation group.
	    </para>
	  </listitem>
	  <listitem>
	    <para><literal><replaceable>func</replaceable>(<replaceable>arguments...</replaceable> over all)</literal>
	    computes the value by considering
	    all input rows, not just those in the current
	    aggregation group.
	    </para>
	  </listitem>
	  <listitem>
	    <para><literal><replaceable>func</replaceable>(<replaceable>arguments...</replaceable> over <replaceable>colspec,...</replaceable> sort by <replaceable>colspec,...</replaceable> )</literal>
	    is a variant of the previous aggregations that forces an ordering on the aggregated values;
	    this is currently only useful for the aggregation function <literal>concat()</literal>.
	    </para>
	  </listitem>
	</orderedlist>
	<variablelist>
	  <varlistentry>
	    <term>count([ over ... ])</term>
	    <listitem><para>Returns the number of input rows considered.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>sum(<replaceable>expression</replaceable> [ over ... ])</term>
	    <listitem><para>For each row considered, computes the expression and returns a sum of the results. The expression must evaluate to a number.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>concat(<replaceable>expression</replaceable>, [<replaceable>"separator"</replaceable>] [ over ... [sort by ...]])</term>
	    <listitem><para>For each row considered, computes the expression and returns a character string  
	    obtained by concatenating the results; the optional
	    second argument may be a literal string to be used as a separator of the concatenated strings. The values are concatenated in
	    no particular order unless the <literal>over ... sort by ...</literal> clause is used.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>min(<replaceable>expression</replaceable> [ over ... ])</term>
	    <listitem><para>For each row considered, computes the expression and returns the minimum of the resulting values. The expression must evaluate to a number.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>max(<replaceable>expression</replaceable> [ over ... ])</term>
	    <listitem><para>For each row considered, computes the expression and returns the maximum of the resulting values. The expression must evaluate to a number.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>avg(<replaceable>expression</replaceable> [ over ... ])</term>
	    <listitem><para>For each row considered, computes the expression and returns the average of the resulting values. The expression must evaluate to a number.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>ratio(<replaceable>expression</replaceable> [ over ... ])</term>
	    <listitem><para>Returns the ratio of the value computed using the expression to the sum of all values computed using this expression over all rows considered.</para></listitem>
	  </varlistentry>
	</variablelist>
      </section>
      <section id="attribute_paths">
	<title>Attribute paths</title>
	<para>
	  Nodes in PML are usually 
	  attribute-value structures with values that can be
	  of either atomic PML data types (integers, strings, etc.) or
	  complex PML data types (structures, lists, alternatives,
	  sequences, containers). This means that to get 
	  to an atomic value
	  stored within a node we sometimes have to travel through several nested
	  complex data structures, starting from the top-level structure 
	  which is the node itself.
	  PML-TQ uses attribute paths to
	  describe the route of such a travel.
	  In this section we define how attribute paths are evaluated.
	</para>
	<para>
	  An attribute path consists of a sequence of 
	  steps separated by slashes. This sequence can be optionally preceded by a primitive quantifier the
	  semantics of which is described later in <xref linkend="quantifiers"/>.
	  Each step is either a name, the string '<literal>[]</literal>',
	  an index, or an element index.
	</para>
	<para>
	  Let <phrase role="math">P</phrase> be an attribute path 
	  consisting of steps 
	  <phrase role="math">S<subscript>1</subscript>,…,S<subscript>m</subscript> (m&gt;0)</phrase>.
	  The result of evaluation of <phrase role="math">P</phrase>
	  on a node <phrase role="math">N</phrase>
	  is a set <phrase role="math">V<subscript>N,P</subscript></phrase> of atomic values
	  (integers, floats, or character strings).
	  The evaluation proceeds by evaluating the steps
	  from 1 to <phrase role="math">m</phrase>; the evaluation
	  of the step <phrase role="math">S<subscript>n</subscript></phrase> (<phrase role="math">1≤n≤m</phrase>)
	  takes as input a set of values <phrase role="math">V<subscript>n</subscript></phrase>
	  and results in a set of values <phrase role="math">V<subscript>n+1</subscript></phrase>.
	  For each <phrase role="math">n</phrase> (<phrase role="math">1≤n≤m+1</phrase>), all
	  values in <phrase role="math">V<subscript>n</subscript></phrase>
	  are of equal data type
	  (which, if <phrase role="math">P</phrase> is a valid attribute path for <phrase role="math">N</phrase>, is complex for <phrase role="math">n≤m</phrase> and atomic for <phrase role="math">n=m+1</phrase>).
	</para>
	<para>
	  The evaluation is initialized with a set
	  <phrase role="math">V<subscript>1</subscript>={N}</phrase>
	  whose only element is
	  the node <phrase role="math">N</phrase>, which
	  is either a structure or a container.
	  The result of the evaluation 
	  if the set <phrase role="math">V<subscript>N,p</subscript>=V<subscript>m+1</subscript></phrase>.
	</para>
	<para>
	  Let <phrase role="math">V<subscript>n</subscript></phrase>
	  be given.
	  We now describe 
	  the evaluation based on the syntactic type of the <phrase role="math">n</phrase>-th step
	  <phrase role="math">S<subscript>n</subscript></phrase>
	  and the data type of values in <phrase role="math">V<subscript>n</subscript></phrase>.
	  Let <phrase role="math">t<subscript>n</subscript></phrase>
	  denote the type of the values in <phrase role="math">V<subscript>n</subscript></phrase>.
	  <itemizedlist>
	    <listitem><para>
	      If <phrase role="math">t<subscript>n</subscript></phrase> is an atomic type (and there is an <phrase role="math">n</phrase>-th step),
	      the query compiler reports an error and fails.</para>
	    </listitem>
	    <listitem><para>
	      If <phrase role="math">t<subscript>n</subscript></phrase> is a structure or container type and
	      <phrase role="math">S<subscript>n</subscript></phrase> is a name of a valid
	      member for <phrase role="math">t<subscript>n</subscript></phrase>
	      (according to the declaration of <phrase role="math">t<subscript>n</subscript></phrase> in the  corresponding PML schema)
	      then 
	      for every element of <phrase role="math">V<subscript>n</subscript></phrase>, <phrase role="math">V<subscript>n+1</subscript></phrase>
	      contains the value of its 
	      member <phrase role="math">S<subscript>n</subscript></phrase>,
	      provided the value is non-null; i.e.
	      <informalequation id="eq-a1">
		<alt role="tex">V_{n+1}=\{v.{S_n}\,;\,v\in V_n\,\&amp;\,\neg\hbox{\sf is-null}(v.{S_n})\}</alt>
		<mediaobject>
		  <imageobject role="html"><imagedata fileref="quantifiers_a1.png" format="PNG" align="center"/></imageobject>
		  <imageobject role="fo"><imagedata fileref="quantifiers_a1.pdf" format="PDF" align="center"/></imageobject>
		</mediaobject>
	      </informalequation>
	      If the step <phrase role="math">S<subscript>n</subscript></phrase> is '<literal>[]</literal>'
	      and  <phrase role="math">t<subscript>n</subscript></phrase> is a container type 
	      with non-void content (i.e. the container has some content type
	      declared in the PML schema),  <phrase role="math">V<subscript>n+1</subscript></phrase>
	      consists of the content value of each element of <phrase role="math">V<subscript>n</subscript></phrase>, i.e.
	      <informalequation id="eq-a2">
		<alt role="tex">V_{n+1}=\{c\,;\,c=\hbox{\sf content-of}(v)\,\&amp;\,v\in V_n\,\&amp;\,\neg\hbox{\sf is-null}(c)\}</alt>
	        <mediaobject>
		  <imageobject role="html"><imagedata fileref="quantifiers_a2.png" format="PNG" align="center"/></imageobject>
		  <imageobject role="fo"><imagedata fileref="quantifiers_a2.pdf" format="PDF" align="center"/></imageobject>
		</mediaobject>
	      </informalequation>
	      If <phrase role="math">S<subscript>n</subscript></phrase> is anything else, the query compiler reports and error and fails.
	    </para></listitem>
	    <listitem>
	    <para>
	      If <phrase role="math">t<subscript>n</subscript></phrase> is an ordered list
	      and <phrase role="math">S<subscript>n</subscript></phrase> is an index
	      of the form <literal>[k]</literal>, where <phrase role="math">k</phrase>
	      is a non-negative integer number, then
	      <phrase role="math">V<subscript>n+1</subscript></phrase> consists
	      of the <phrase role="math">(k+1)</phrase>-th value (<phrase role="math">v[k]</phrase>)
	      of each list in <phrase role="math">V<subscript>n</subscript></phrase>
	      whose length is at least <phrase role="math">k+1</phrase>, i.e.
	      <informalequation id="eq-a3">
		<alt role="tex">V_{n+1}=\{v[k]\,;\,v\in V_n\,\&amp;\,\hbox{\sf length}(v)&gt;k\,\&amp;\,v[k\neg\hbox{\sf is-null}(])\}</alt>
	        <mediaobject>
		  <imageobject role="html"><imagedata fileref="quantifiers_a3.png" format="PNG" align="center"/></imageobject>
		  <imageobject role="fo"><imagedata fileref="quantifiers_a3.pdf" format="PDF" align="center"/></imageobject>
		</mediaobject>
	      </informalequation>
	    </para></listitem>
	    <listitem>
	    <para>
	      If <phrase role="math">t<subscript>n</subscript></phrase> is a list or an alternative,
	      and <phrase role="math">S<subscript>n</subscript></phrase> is any step
	      except for the case covered above (where 
	      <phrase role="math">t<subscript>n</subscript></phrase> was an ordered list  
	      and <phrase role="math">S<subscript>n</subscript></phrase> an index), 
	      let <phrase role="math">V'<subscript>n</subscript></phrase> consist
	      of all non-null values that occur in some list or alternative
	      from  <phrase role="math">V<subscript>n</subscript></phrase>, i.e.
	      <informalequation id="eq-a3">
		<alt role="tex">V'_{n}=\{w\,;\,(\exists v\in V_n)(\exists k&lt;\hbox{\sf length}(v))(w=v[k]\,\&amp;\,\neg\hbox{\sf is-null}(w))\}</alt>
	        <mediaobject>
		  <imageobject role="html"><imagedata fileref="quantifiers_a3.png" format="PNG" align="center"/></imageobject>
		  <imageobject role="fo"><imagedata fileref="quantifiers_a3.pdf" format="PDF" align="center"/></imageobject>
		</mediaobject>
	      </informalequation>
	      Then <phrase role="math">V<subscript>n+1</subscript></phrase>
	      is obtained by applying the step 
	      <phrase role="math">S<subscript>n</subscript></phrase>
	      on the set 
	      <phrase role="math">V'<subscript>n</subscript></phrase>
	      instead according to these rules.
	    </para>
	    </listitem>
	    <listitem>
	    <para>
	      If <phrase role="math">t<subscript>n</subscript></phrase> is a sequence type
	      and <phrase role="math">S<subscript>n</subscript></phrase> is an element name <phrase role="math">E</phrase> valid
	      for the sequence type <phrase role="math">t<subscript>n</subscript></phrase>,
	      then 
	      <phrase role="math">V<subscript>n+1</subscript></phrase> consists
	      of all non-null values of elements with a given
	      name occurring in some sequence from 
	      <phrase role="math">V<subscript>n</subscript></phrase>, i.e.

	      <informalequation id="eq-a4">
		<alt role="tex">V_{n+1}=\{w\,;\,(\exists v\in V_n)(\exists k&lt;\hbox{\sf length}(v))(\hbox{\sf name-of}(v[k])=E\,\&amp;\,w=\hbox{\sf value-of}(v[k])\,\&amp;\,\neg\hbox{\sf is-null}(w))\}</alt>
	        <mediaobject>
		  <imageobject role="html"><imagedata fileref="quantifiers_a4.png" format="PNG" align="center"/></imageobject>
		  <imageobject role="fo"><imagedata fileref="quantifiers_a4.pdf" format="PDF" align="center"/></imageobject>
		</mediaobject>
	      </informalequation>

	    </para>
	    <para>
	      If <phrase role="math">S<subscript>n</subscript></phrase> is of the form
	      '<literal>E[k]</literal>', where
	      <phrase role="math">E</phrase> is a valid element name for 
	      <phrase role="math">t<subscript>n</subscript></phrase> and <phrase role="math">k</phrase>
	      is a non-negative integer number,
	      then for each sequence in <phrase role="math">V<subscript>n</subscript></phrase> 
	      the <phrase role="math">(k+1)</phrase>-st occurrence of element named <phrase role="math">E</phrase>
	      (if exists) is taken and the element's value, if non-null,
	      is added to <phrase role="math">V<subscript>n+1</subscript></phrase>. Formally,
	      <informalequation id="eq-a5">
		<?dbtex delims='no'?>
		<alt role="tex">
		  \begin{equation*}
		  \begin{split}
		  V_{n+1}=\{w\,;\,(\exists v\in V_n)(\exists k&lt;\hbox{\sf length}(v))(
		  &amp;\#\{l&lt;k \,;\, \hbox{\sf name-of}(v[l])=E \}=k\\
		  &amp;\,\&amp;\,\hbox{\sf name-of}(v[k])=E\\
		  &amp;\,\&amp;\,\hbox{\sf value-of}(v[k])=w \,\&amp;\,\neg\hbox{\sf is-null}(w))\}
		  \end{split}
		\end{equation*}
		</alt>

	        <mediaobject>
		  <imageobject role="html"><imagedata fileref="quantifiers_a5.png" format="PNG" align="center"/></imageobject>
		  <imageobject role="fo"><imagedata fileref="quantifiers_a5.pdf" format="PDF" align="center"/></imageobject>
		</mediaobject>
	      </informalequation>
	    </para>
	    <para>
	      If <phrase role="math">S<subscript>n</subscript></phrase> is of the form
	      '<literal>[k]E</literal>', where
	      <phrase role="math">E</phrase> is a valid element name for 
	      <phrase role="math">t<subscript>n</subscript></phrase> and <phrase role="math">k</phrase>
	      is a non-negative integer number,
	      then for each sequence in <phrase role="math">V<subscript>n</subscript></phrase> 
	      of length at least <phrase role="math">k+1</phrase> the
	      <phrase role="math">(k+1)</phrase>-st element is taken
	      and if its name is <phrase role="math">E</phrase> and its  value is non-null,
	      the value is added to <phrase role="math">V<subscript>n+1</subscript></phrase>. Formally,
	      <informalequation id="eq-a6">
		<?dbtex delims='no'?>
		<alt role="tex">
		  \begin{equation*}
		  \begin{split}
		  V_{n+1}=\{w\,;\,(\exists v\in V_n)(&amp;\hbox{\sf length}(v)&gt;k\,\&amp;\, \hbox{\sf name-of}(v[k])=E\\
		  &amp;\,\&amp;\,w=\hbox{\sf value-of}(v[k])\,\&amp;\,\neg\hbox{\sf is-null}(w))\}
		  \end{split}
		\end{equation*}</alt>
	        <mediaobject>
		  <imageobject role="html"><imagedata fileref="quantifiers_a6.png" format="PNG" align="center"/></imageobject>
		  <imageobject role="fo"><imagedata fileref="quantifiers_a6.pdf" format="PDF" align="center"/></imageobject>
		</mediaobject>
	      </informalequation>
	    </para>
	    </listitem>
	  </itemizedlist>
	</para>
      </section>
      <section id="quantifiers">
	<title>Primitive quantifiers</title>
	<para>
	  As described above, evaluation of an attribute path 
	  on some node may result in a set of values
	  (usually empty or containing one element, but if
	  lists, alternatives or sequences are on the path, the
	  set can be of arbitrary finite cardinality).
	  In this section we define how the truth value of a predicate involving
	  attribute paths is evaluated.
	  We start with the formal definition and then demonstrate it on a few examples. 
	</para>
	<formalpara>
	  <title>Definition</title>
	<para>
	  Let <phrase role="math">R</phrase> be a predicate
	  and let <phrase role="math">p<subscript>1</subscript>,…,p<subscript>n</subscript></phrase>
	  be an enumeration of all occurrences of attribute paths in expressions (terms)
	  contained in <phrase role="math">R</phrase> in the order of occurrence
	  and let <phrase role="math">N<subscript>1</subscript>,…,N<subscript>n</subscript></phrase>
	  be the nodes to which the attribute paths relate.
	  Let for <phrase role="math">i</phrase> (<phrase role="math">1≤<phrase role="math">i</phrase>≤n</phrase>),  <phrase role="math">Q<subscript><phrase role="math">i</phrase></subscript></phrase>
	  denote the universal quantifier
	  <inlineequation>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="quantifier_for_all.png" format="PNG"/></imageobject>
	    <textobject role="tex"><phrase>\forall</phrase></textobject>
	    <textobject><phrase>∀</phrase></textobject>
	  </inlinemediaobject>
	  </inlineequation>
	  if <phrase role="math">p<subscript><phrase role="math">i</phrase></subscript></phrase>
	  starts with a '<phrase role="math">*</phrase>'
	  and 
	  <inlineequation>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="quantifier_exists.png" format="PNG"/></imageobject>
	    <textobject role="tex"><phrase>\exists</phrase></textobject>
	    <textobject><phrase>∃</phrase></textobject>
	  </inlinemediaobject>
	  </inlineequation>
	  otherwise.
	  Let <phrase role="math">V<subscript>i</subscript></phrase>
	  deonte the set 
	  <phrase role="math">V<subscript>N<subscript>i</subscript>,p<subscript>i</subscript></subscript></phrase>
	  of atomic values obtained by evaluating the attribute paths
	  <phrase role="math">p<subscript>i</subscript></phrase>
	  on the node <phrase role="math">N<subscript>i</subscript></phrase>.
	  Then the truth value of the predicate <phrase role="math">R</phrase> for this assignment
	is that of the formula
	<inlineequation id="eq-r1">
	  <alt role="tex">(Q_1 x_1 \in V_1)\ldots(Q_n x_n \in V_n)R'</alt>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="quantifiers_r1.png" format="PNG"/></imageobject>
	    <imageobject role="fo"><imagedata fileref="quantifiers_r1.pdf" format="PDF"/></imageobject>
	  </inlinemediaobject>
	</inlineequation>
	where <phrase role="math">R'</phrase> is an atomic formula
	obtained from <phrase role="math">R</phrase>
	by replacing the attribute paths
	<phrase role="math">p<subscript>1</subscript>,…,p<subscript>n</subscript></phrase>
	by variables
	<phrase role="math">x<subscript>1</subscript>,…,x<subscript>n</subscript></phrase>.
	(Note that each of the variables has exactly one occurrence in <phrase role="math">R'</phrase>.)
	</para>
	</formalpara>
	<para>
	  Now let us demonstrate the definition on some examples.
	  Let <phrase role="math">R</phrase> be
	  the predicate 
	  <programlisting>*a != b/c + *$n.d/e/f</programlisting>
	  in the query
	  <programlisting>z-node $n := [ child z-node $m := [ *a != b/c + *$n.d/e/f ] ]</programlisting>
	  where <literal>z-node</literal> is some node type, and
	  <literal>a</literal> 
	  <literal>b/c</literal>,
	  <literal>d/e/f</literal>
	  are valid attribute paths for
	  nodes of this type.
	  Let <phrase role="math">N</phrase> and
	  <phrase role="math">M</phrase> be 
	  nodes from the searched data
	  assigned to the selectors <literal>$n</literal>
	  and <literal>$m</literal>.
	</para>
	<para>
	  Let's assume
	  that the attribute <literal>a</literal> is a list of numbers
	  and that <phrase role="math">V<subscript>N,a</subscript></phrase>
	  is the set of all values of the attribute
	  <literal>a</literal> for the node <phrase role="math">N</phrase>.
	  Similary, let 
	  <phrase role="math">V<subscript>M,b/c</subscript></phrase>
	  be the set of all values of the attribute path
	  <literal>b/c</literal> evaluated on the node <phrase role="math">M</phrase>
	  and
	  <phrase role="math">V<subscript>N,d/e/f</subscript></phrase>
	  the set of all values of the attribute path
	  <literal>d/e/f</literal> evaluated on the node <phrase role="math">N</phrase>.
	</para>
	<para>The truth value of the predicate <phrase role="math">R</phrase>
	is obtained by evaluating the following formula:
	<informaltable pgwide="1" colsep="0" rowsep="0" frame="none">
		<tgroup cols="2" colsep="0pt" >
		  <colspec colnum="1" align="center" colwidth="95"/>
		  <colspec colnum="2" align="right" colwidth="5"/>
		  <tbody>
		    <row><entry>
		      <para>
	<informalequation id="eq-1">
	  <alt role="tex">
	    (\forall x \in V_{N,a})(\exists y \in V_{M,b/c})(\forall z \in V_{N,d/e/f}) x\neq y + z
	  </alt>
	  <mediaobject>
	    <imageobject role="html">
	      <imagedata align="center" fileref="quantifiers_f1.png" format="PNG"/>
	    </imageobject>
	<imageobject role="fo">
	      <imagedata align="center" fileref="quantifiers_f1.pdf" format="PDF"/>
	    </imageobject></mediaobject></informalequation>
		      </para>
	    </entry><entry>(1)</entry>
		    </row>
		  </tbody>
		</tgroup>
	      </informaltable>

	Thus, the query matches the nodes A, B if and only if
	B is a child of A and the above formula holds.
	Note that since the attribute paths
	<literal>*a</literal>
	and
	<literal>*$a.d/e/f</literal>
	start with the character '<literal>*</literal>'
	(called a primitive universal quantifier)
	the corresponding variables <phrase role="math">x</phrase> and <phrase role="math">z</phrase>
	in the formula <link linkend="eq-1">(1)</link>
	are universally quantified,
	whereas 
	<phrase role="math">y</phrase>,
	corresponding to <literal>b/c</literal>
	is quantified existentially.
	Note also, that the order of the quantifiers 
	in the formula  <link linkend="eq-1">(1)</link>
	preserves the order of the occurrence of 
	the corresponding attribute paths in <phrase role="math">R</phrase>.
	</para>
	<para>
	  If we had instead written 
	  <programlisting>! *a = b/c + *$n.d/e/f</programlisting>
	  moving the negation (<literal>!</literal>) out of the predicate,
	  the resulting formula would be completely different:
	      <informaltable pgwide="1" colsep="0" rowsep="0" frame="none">
		<tgroup cols="2" colsep="0pt" >
		  <colspec colnum="1" align="center" colwidth="95"/>
		  <colspec colnum="2" align="right" colwidth="5"/>
		  <tbody>
		    <row><entry>
		      <para>
	<informalequation id="eq-2">
	  <alt role="tex">
	    \neg(\forall x \in V_{N,a})(\exists y \in V_{M,b/c})(\forall z \in V_{N,d/e/f}) x= y + z
	  </alt>
	  <mediaobject>
	    <imageobject role="html">
	      <imagedata fileref="quantifiers_f2.png" format="PNG" align="center"/>
	    </imageobject>
	<imageobject role="fo">
	      <imagedata fileref="quantifiers_f2.pdf" format="PDF" align="center"/>
	    </imageobject></mediaobject></informalequation>
		      </para>
	    </entry><entry>(2)</entry>
		    </row>
		  </tbody>
		</tgroup>
	      </informaltable>

	and equivalent to 
	      <informaltable pgwide="1" colsep="0" rowsep="0" frame="none">
		<tgroup cols="2" colsep="0pt" >
		  <colspec colnum="1" align="center" colwidth="95"/>
		  <colspec colnum="2" align="right" colwidth="5"/>
		  <tbody>
		    <row><entry>
		      <para>
	<informalequation id="eq-3">
	  <alt role="tex">
	    (\exists x \in V_{N,a})(\forall y \in V_{M,b/c})(\exists z \in V_{N,d/e/f}) x\neq y + z
	  </alt>
	  <mediaobject>
	    <imageobject role="html">
	      <imagedata fileref="quantifiers_f3.png" format="PNG" align="center"/>
	    </imageobject>
	<imageobject role="fo">
	      <imagedata fileref="quantifiers_f3.pdf" format="PDF" align="center"/>
	    </imageobject></mediaobject></informalequation>
		      </para>
	    </entry><entry>(3)</entry>
		    </row>
		  </tbody>
		</tgroup>
	      </informaltable>

	</para>
	<para>
	  Let us give some more practical examples. 
	  Assume nodes of the type <literal>p-node</literal> have an attribute
	  <literal>functions</literal> that is an unordered list or an alternative of string values.
	  Let us consider the following constraints and the translations to formulae
	  (assuming <phrase role="math">V<subscript>N</subscript></phrase> is the set of values of the <literal>functions</literal> 
	  for a given p-node <phrase role="math">N</phrase>):
	</para>
	<orderedlist>
	  <listitem>
	  <para><literal>functions = functions</literal> asserts that
	  the list <literal>functions</literal>  on <phrase role="math">N</phrase>  is non-empty, since
	  the constraint translates to the formula
	<inlineequation id="eq-5">
	  <alt role="tex">
	    \qquad\qquad (\exists x \in V_N)(\exists y \in V_N)x=y
	  </alt>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="quantifiers_f5.png" format="PNG"/></imageobject>
	    <imageobject role="fo"><imagedata fileref="quantifiers_f5.pdf" format="PDF"/></imageobject>
	  </inlinemediaobject>
	</inlineequation>
	which is equvalent to 
	<inlineequation>
	  <alt role="tex">(\exists x \in V_N)x=x</alt>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="quantifiers_f5_1.png" format="PNG"/></imageobject>
	    <imageobject role="fo"><imagedata fileref="quantifiers_f5_1.pdf" format="PDF"/></imageobject>
	  </inlinemediaobject>
	</inlineequation>
	and to
	<inlineequation>
	  <alt role="tex">V_N\neq\emptyset</alt>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="quantifiers_f5_2.png" format="PNG"/></imageobject>
	    <imageobject role="fo"><imagedata fileref="quantifiers_f5_2.pdf" format="PDF"/></imageobject>
	  </inlinemediaobject>
	</inlineequation>.
	  </para>
	  </listitem>
	  <listitem>
	  <para><literal>functions != functions</literal> asserts that
	  the list <literal>functions</literal>  on <phrase role="math">N</phrase>  contains
	  (at least) two distinct strings, since
	  it translates to 
	<inlineequation id="eq-6">
	  <alt role="tex">
	    \qquad\qquad (\exists x \in V_N)(\exists y \in V_N)x\neq y
	  </alt>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="quantifiers_f6.png" format="PNG"/></imageobject>
	    <imageobject role="fo"><imagedata fileref="quantifiers_f6.pdf" format="PDF"/></imageobject>
	  </inlinemediaobject>
	</inlineequation>.
	  </para>
	  </listitem>
	  <listitem>
	  <para><literal>!functions = functions</literal> means that 
	  the list <literal>functions</literal>  on <phrase role="math">N</phrase>  is empty, since
	  it is a negation of <literal>functions=functions</literal> .</para>
</listitem>
	  <listitem>
	  <para><literal>*functions = *functions</literal> asserts that the list <literal>functions</literal>  on <phrase role="math">N</phrase>  contains
	  at most one unique value because it translates to
	<inlineequation id="eq-7">
	  <alt role="tex">
	    \qquad\qquad (\forall x \in V_N)(\forall y \in V_N)x= y
	  </alt>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="quantifiers_f7.png" format="PNG"/></imageobject>
	    <imageobject role="fo"><imagedata fileref="quantifiers_f7.pdf" format="PDF"/></imageobject>
	  </inlinemediaobject>
</inlineequation>,
	which is satisfied if the set <phrase role="math">V<subscript>N</subscript></phrase> 
	is either empty or contains exactly one element.
	  </para>
	  </listitem>
	  <listitem>
	  <para><literal>*functions = functions</literal> is always satisfied, because it translates to
	<inlineequation id="eq-8">
	  <alt role="tex">
	    \qquad\qquad (\forall x \in V_N)(\exists y \in V_N)x= y
	  </alt>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="quantifiers_f8.png" format="PNG"/></imageobject>
	    <imageobject role="fo"><imagedata fileref="quantifiers_f8.pdf" format="PDF"/></imageobject>
	  </inlinemediaobject>
</inlineequation>.
	  </para>
	  </listitem>
	  <listitem>
	  <para><literal>functions = *functions</literal> asserts that the list
	  <literal>functions</literal>  contains exactly one unique value,
	  since it translates to
	<inlineequation id="eq-9">
	  <alt role="tex">
	    \qquad\qquad (\exists x \in V_N)(\forall y \in V_N)x=y
	  </alt>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="quantifiers_f9.png" format="PNG"/></imageobject>
	    <imageobject role="fo"><imagedata fileref="quantifiers_f9.pdf" format="PDF"/></imageobject>
	  </inlinemediaobject>
</inlineequation>.
	  </para>
	  </listitem>
	  <listitem>
	  <para><literal>*functions != functions</literal> asserts that the list 
	  <literal>functions</literal>  is either empty
	  or contains at least two unique value,
	  since it translates to
	<inlineequation id="eq-10">
	  <alt role="tex">
	    \qquad\qquad (\forall x \in V_N)(\exists y \in V_N)x\neq y
	  </alt>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="quantifiers_f10.png" format="PNG"/></imageobject>
	    <imageobject role="fo"><imagedata fileref="quantifiers_f10.pdf" format="PDF"/></imageobject>
	    </inlinemediaobject>
</inlineequation>.
	  </para>
	  </listitem>
	  <listitem>
	  <para><literal>functions != *functions</literal> translates to
	<inlineequation id="eq-11">
	  <alt role="tex">
	    \qquad\qquad (\exists x \in V_N)(\forall y \in V_N)x\neq y
	  </alt>
	  <inlinemediaobject>
	    <imageobject role="html"><imagedata fileref="quantifiers_f11.png" format="PNG"/></imageobject>
	    <imageobject role="fo"><imagedata fileref="quantifiers_f11.pdf" format="PDF"/></imageobject>
	  </inlinemediaobject>
</inlineequation>,
	which is never satisfied
	(since x=x).
	  </para>
	  </listitem>
	</orderedlist>
      </section>
    </section>
    <section>
    <title>Examples</title>
    <para/>
  </section>
  <section>
    <title>Graphical representation in TrEd</title>
    <para>
    </para>
  </section>
  <section>
    <title>TrEd search interface</title>
    <para>
    </para>
  </section>
  <section>
    <title>Web interface</title>
    <para/>
  </section>
  <section>
    <title>Command-line interface</title>
    <para>
      <!--
      describe 'pmltq' command-line utility,
      describe usage from btred command line
      -->
    </para>
  </section>
  <section>
    <title>BTrEd interface</title>
    <para/>
  </section>
  <section>
    <title>Installing SQL Server and HTTP Proxy</title>
    <para>
    </para>
  </section>
  <section>
    <title>Tools</title>
    <para/>
  </section>
</article>

