<?xml version="1.0" encoding="utf-8"?>
<article lang="en">
  <articleinfo>
    <author>
      <firstname>Petr</firstname>
      <surname>Pajas</surname>
    </author>
    <title>PML Tree Query</title>
  </articleinfo>
  <section>
    <title>Introduction</title>
    <para>
      Purpose, features, comparison with other query engines
      (NetGraph, TGrep2)
    </para>
    <orderedlist>
      <listitem>
	<para>search over all layers of annotation (including annotation dictionaries)</para>
      </listitem>
      <listitem>
	<para>graphical query view with relations between nodes represented by arrows</para>
      </listitem>
      <listitem>
	<para>interface with TrEd</para>
      </listitem>
      <listitem>
	<para>operates on original data (no conversion, no information loss)</para>
      </listitem>
      <listitem>
	<para>arbitrary logical conditions</para>
      </listitem>
      <listitem>
	<para>output filters: multi-column text output (attribute values, statistical analysis, ...)</para>
      </listitem>
    </orderedlist>
  </section>
  <section>
    <title>Tutorial</title>
    <para>
      Step by step tutorial (TrEd based).
    </para>
  </section>
  <section>
    <title>Query Language</title>
    <para>
      Basic examples, syntax reference.
    </para>
    <section>
      <title>Brief PML-TQ syntax reference</title>
      <variablelist>
	<varlistentry>
	  <term>node</term>
	  <listitem>
	    <synopsis>node :: <replaceable>relation</replaceable>? <replaceable>type</replaceable> ($<replaceable>name</replaceable> ':=' )? '[' <replaceable>conditions</replaceable>?  ']'</synopsis>
	    <mediaobject id="rail_node">
	      <textobject role="syntax_diagram">
		<simpara><![CDATA[ node : TYPE (variable ':=' )? \\ '[' conditions?  ']' ;
 ]]></simpara>
	      </textobject>
	      <imageobject>
		<imagedata format="linespecific" fileref="rail_node.pdf"/>
	      </imageobject>
	      <imageobject>
		<imagedata format="PNG" fileref="rail_node.png"/>
	      </imageobject>
	    </mediaobject>

	      <para>Defines a query node 
	      matching any node of type <replaceable>type</replaceable>
	      whose relation to 
	      its parent query node is <replaceable>relation</replaceable>
	      (<replaceable>relation</replaceable> is <literal>child</literal> if not specified)
	      and (optionally) named $<replaceable>name</replaceable> for reference 
	      from other nodes.
	      </para>
	      <para>
		For example, the query <literal>a-node $a := [ descendant a-node [ afun=$a.afun ]  ]  ]</literal>
		over PDTÂ 2.0 data selects analytical
		nodes whose subtree contains an analytical node with the same value
		of the attribute <literal>afun</literal> (the query returns 
		pairs of nodes in the described relation).
	      </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>variable</term>
	  <listitem>
	    <synopsis>variable :: '$' <replaceable>NAME</replaceable></synopsis>
	    <mediaobject id="rail_variable">
	      <textobject role="syntax_diagram">
		<simpara><![CDATA[ variable : DOLLAR NAME ]]></simpara>
	      </textobject>
	      <imageobject>
		<imagedata format="linespecific" fileref="rail_variable.pdf"/>
	      </imageobject>
	      <imageobject>
		<imagedata format="PNG" fileref="rail_variable.png"/>
	      </imageobject>
	    </mediaobject>
	    <para>Variables are used to name query nodes and refer to them
	    from other parts of the query. Variable starts
	    with a '$' (dollar) character and is followed by 
	    a NAME consisting of alphabetical character or underscore
	    and zero or more alphanumerical characters or underscores.
	    For example, <literal>$foo_02</literal> or <literal>$x</literal> are
	    valid variable names, while <literal>$23</literal> is not.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>optionalNode</term>
	  <listitem>
	    <synopsis>optional_node :: '?' <replaceable>node</replaceable></synopsis>
	    <mediaobject id="rail_optionalNode">
	      <textobject role="syntax_diagram">
		<simpara><![CDATA[ optionalNode : '?' node; ]]></simpara>
	      </textobject>
	      <imageobject>
		<imagedata format="linespecific" fileref="rail_optionalNode.pdf"/>
	      </imageobject>
	      <imageobject>
		<imagedata format="PNG" fileref="rail_optionalNode.png"/>
	      </imageobject>
	    </mediaobject>

	      <para>
		If the query node is preceded by a question mark,
		this query node is optional. This means, that if no node
		matches this node, the node is assumed to match the same node
		as its parent node in the query. All child nodes or subqueries of the optional
		node must then be in the corresponding relation to this parent node.
		For example, <literal>a-node $a := [ afun='Sb', ? a-node $b:= [ afun='AuxC', $c := [ afun='Obj']  ]  ]</literal>
		with $b optional,
		matches either a descending chain of three a-nodes 
		'Sb-&gt;AuxC-&gt;Obj' 
		(the optional node $b matching the middle node)
		or just the pair
		'Sb-&gt;Obj', in which case both $a and $b are identified with the 'Sb'
		(the condition <literal>afun='AuxC'</literal>) on $b is disregarded),
		but it does <emphasis>not</emphasis>, for instance, match a descending chain 'Sb-&gt;ExD-&gt;Obj'.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>subquery</term>
	    <listitem>
	      <synopsis>subquery :: <replaceable>occurrences</replaceable> 'x' <replaceable>node</replaceable>
occurrences :: ( <replaceable>n</replaceable> | <replaceable>n</replaceable> '+' | <replaceable>n</replaceable> '-' | <replaceable>n</replaceable> '..' <replaceable>m</replaceable> ) ('|' <replaceable>occurrences</replaceable>)*</synopsis>
	    <mediaobject id="subquery">
	      <textobject role="syntax_diagram">
		<simpara><![CDATA[ subquery : occurrences 'x' RELATION? node;
occurrences : ( NUMBER | NUMBER '+' | NUMBER '-' | NUMBER '..' NUMBER ) + '|';
 ]]></simpara>
	      </textobject>
	      <imageobject>
		<imagedata format="linespecific" fileref="rail_subquery.pdf"/>
	      </imageobject>
	      <imageobject>
		<imagedata format="PNG" fileref="rail_subquery.png"/>
	      </imageobject>
	    </mediaobject>
	      <para>Subquery is a subtree in the query tree that
	      specifies number of occurrences. For example,
	      <literal>3x</literal> specifies that the subtree must
	      match <emphasis>exactly</emphasis> three times,
	      <literal>3+x</literal> specifies that the subtree must
	      match <emphasis>at least</emphasis> three times,
	      <literal>3-x</literal> specifies that the subtree must
	      match <emphasis>at most</emphasis> three times and
	      <literal>3-10x</literal> specifies that the subtree must
	      match <emphasis>at least</emphasis> three times but at
	      most ten times.
	      </para>
	      <note><para>Nodes beloning to a subquery cannot be
	      referred to by name from outside the subquery.</para></note>
	  </varlistentry>
	  <varlistentry>
	    <term>conditions</term>
	    
	    <listitem><synopsis>conditions :: <replaceable>condition</replaceable> (',' condition)*</synopsis>
	    <mediaobject id="rail_conditions">
	      <textobject role="syntax_diagram">
		<simpara><![CDATA[ conditions : condition + ',';]]></simpara>
	      </textobject>
	      <imageobject>
		<imagedata format="linespecific" fileref="rail_conditions.pdf"/>
	      </imageobject>
	      <imageobject>
		<imagedata format="PNG" fileref="rail_conditions.png"/>
	      </imageobject>
	    </mediaobject>

	    <para>One or more conditions.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>condition</term>
	    
	    <listitem><synopsis>condition :: 
	      <replaceable>atomic_predicate</replaceable> | 
	      <replaceable>set_predicate</replaceable> | 
	      <replaceable>node</replaceable> | 
	      <replaceable>subquery</replaceable> |
	      <replaceable>relation</replaceable> $<replaceable>name</replaceable> |
	      <replaceable>logical</replaceable></synopsis>
	    <mediaobject id="rail_condition">
	      <textobject role="syntax_diagram">
		<simpara><![CDATA[ condition : ((atomicPredicate | setPredicate | RELATION? node | RELATION variable | subquery |  '(' condition ')' | '!' condition ) + ('and' | 'or' )) ;
 ]]></simpara>
	      </textobject>
	      <imageobject>
		<imagedata format="linespecific" fileref="rail_condition.pdf"/>
	      </imageobject>
	      <imageobject>
		<imagedata format="PNG" fileref="rail_condition.png"/>
	      </imageobject>
	    </mediaobject>
<para>
	      A condition is either a 
	    binary test predicate
	    (<literal>=</literal>, 
	    <literal>~</literal>, 
	    <literal>&lt;</literal>
	    <literal>&lt;=</literal>
	    <literal>&gt;</literal> etc.) on
	    expressions computed from atomic values,
	    or a node or subquery,
	    or a reference to a named node
	    (indicating that the referred query
	    node is in the corresponding relation to the current node)
	    or a logical combination of any of these except for 
	    nodes (a query node used in a logical expressoin is
	    treated as a subquery with at least on occurrence).
	      </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>atomic_predicate</term>
	    
	    <listitem><synopsis>atomic_predicate :: ( <replaceable>expression</replaceable> ('=' | '~' | '~*' | '&lt;' | '&gt;' | '&lt;=' | '&gt;=') <replaceable>expression</replaceable>  </synopsis>
	    <mediaobject id="rail_atomic_predicate">
	      <textobject role="syntax_diagram">
		<simpara><![CDATA[ atomicPredicate : expression ('=' | TILDA | TILDASTAR | '<' | '>' | '<=' | '>=') expression  ;
 ]]></simpara>
	      </textobject>
	      <imageobject>
		<imagedata format="linespecific" fileref="rail_atomicPredicate.pdf"/>
	      </imageobject>
	      <imageobject>
		<imagedata format="PNG" fileref="rail_atomicPredicate.png"/>
	      </imageobject>
	    </mediaobject>

	      <para>
		The atomic predicate consists of two expressions 
		and a binary relation. 
	      </para>
	      <para>
		The relations <literal>~</literal> and
		<literal>~*</literal> perform 
		case-sensitive and case-insensitive
		regular expression
		matching, respectivelly. The
		expression on the right must evaluate
		to a regular expression. For example
		<literal>afun ~ '^(Sb|Aux.*)$'</literal>
		is true if the value of the attribute
		<literal>afun</literal> of the current query node
		either equals to the string <literal>Sb</literal> or
		starts with the string <literal>Aux</literal>.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>set_predicate</term>
	    <listitem><synopsis>set_predicate :: <replaceable>expression</replaceable> 'in' '{' <replaceable>expression</replaceable> ( ',' <replaceable>expression</replaceable> )* '}' )</synopsis>
	    <mediaobject id="rail_set_predicate">
	      <textobject role="syntax_diagram">
		<simpara><![CDATA[ setPredicate : (expression 'in' LEFTBRACE (expression +',') RIGHTBRACE) ; ]]></simpara>
	      </textobject>
	      <imageobject>
		<imagedata format="linespecific" fileref="rail_setPredicate.pdf"/>
	      </imageobject>
	      <imageobject>
		<imagedata format="PNG" fileref="rail_setPredicate.png"/>
	      </imageobject>
	    </mediaobject>

	      <para>
		This predicate is true
		if the value computed from the expression on the left
		equals some of the values computed from the expressions
		listed in curly brackets on the right.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>expression</term>
	    
	    <listitem><synopsis>expression :: <replaceable>literal</replaceable> 
  	    | <replaceable>function</replaceable> 
	    | <replaceable>expression</replaceable> (('+' | '-' | '*' | 'div' | 'mod' | '&amp;') <replaceable>expression</replaceable> )+ 
	    | '(' <replaceable>expression</replaceable> ')' </synopsis>
	    <mediaobject id="rail_expression">
	      <textobject role="syntax_diagram">
		<simpara><![CDATA[ expression : (literal | attributePath | function | '(' expression ')') + ('+' | '-' | '*' | 'div' | 'mod' | AMP)  ; ]]></simpara>
	      </textobject>
	      <imageobject>
		<imagedata format="linespecific" fileref="rail_expression.pdf"/>
	      </imageobject>
	      <imageobject>
		<imagedata format="PNG" fileref="rail_expression.png"/>
	      </imageobject>
	    </mediaobject>

	      <para>
		Expressions are either literals (strings, integer of
		floating point numbers), or functions, or any
		combination of these obtain by application of the
		binary string-concatenation operator ('&amp;') or the
		usual arithmetical operations for addition ('+'),
		subtraction ('-'), multiplication ('*'), division
		('div') and modulo ('mod'). Brackets can be used in the usual manner
		for grouping sub-expressions.
	      </para>
	      <para>For example, <literal>afun &amp; "." &amp; substr(m/tag,0,2)</literal>
	      is an expression returning a concatenation of the value of the attribute <literal>afun</literal>,
	      a dot and the first two characters from the value of the attribute <literal>m/tag</literal>.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>literal</term>
	    
	    <listitem><synopsis>literal :: NUMBER | '"' STRING '"' | ''' STRING '''</synopsis>
	    <mediaobject id="rail_literal">
	      <textobject role="syntax_diagram">
		<simpara><![CDATA[ literal : NUMBER | '"' STRING '"' | "'" STRING "'" ; ]]></simpara>
	      </textobject>
	      <imageobject>
		<imagedata format="linespecific" fileref="rail_literal.pdf"/>
	      </imageobject>
	      <imageobject>
		<imagedata format="PNG" fileref="rail_literal.png"/>
	      </imageobject>
	    </mediaobject>

	      <para>A literal is either a number in the decimal
	      notation (integer or floating point,
	      e.g. <literal>231</literal> or
	      <literal>-1.0032</literal>) or a string of characters
	      enclosed in either <literal>"</literal> or
	      <literal>'</literal>.  Backslash character
	      <literal>\</literal> can be used as an escape character,
	      for example to insert a quote or apostroph.
	      </para>
	      <para>
		For example: both <literal>"Peter's"</literal> and
	      <literal>'Peter\'s'</literal> both represent the literal
	      string <literal>Peter's</literal> and
	      both
	      <literal>'\\\"\'\n\r'</literal> and
	      <literal>"\\\"\'\n\r"</literal> represent
	      the literal five-character string <literal>\"'nr</literal>.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>attributePath</term>
	    <listitem><synopsis>attributePath :: (variable '.')? XMLNAME ('/' XMLNAME)*</synopsis>
	    <mediaobject id="rail_attributePath">
	      <textobject role="syntax_diagram">
		<simpara><![CDATA[ attributePath : (variable '.' )? XMLNAME + '/' ; ]]></simpara>
	      </textobject>
	      <imageobject>
		<imagedata format="linespecific" fileref="rail_attributePath.pdf"/>
	      </imageobject>
	      <imageobject>
		<imagedata format="PNG" fileref="rail_attributePath.png"/>
	      </imageobject>
	    </mediaobject>
	    <para>
	      An attribute path refers to
	      a value of an attribute of a treebank node
	      matched by certain query node.
	      If the path starts with a variable followed by
	      a '.' (dot) character, then the it refers
	      to an attribute of the node matched by the
	      query node named by the variable.
	      Otherwise it refers to the node matched
	      by the current query node (i.e.
	      the node within whose constraints
	      it occurs).
	    </para>
	    <para>
	      In the simplest form,
	      attribute path is just a name of an attribute,
	      e.g. <literal>functor</literal>.
	      However, some node attributes may have complex
	      values, i.e. structures with attributes of their own.
	      In such case one forms a slash-delimited attribute
	      path leading from the node
	      to some nested atomic value. For example
	      <literal>gram/sempos</literal> selects
	      the attribtue <literal>sempos</literal>
	      of a structure stored in the attribute
	      <literal>gram</literal> of the current node.
	    </para>
	    <para>
	      Example:
	      <programlisting>a-node $p:= [ child a-node [ afun=$p.afun, afun~'^Aux' ] ]</programlisting>
	      The above query selects
	      a node its child node (both of type <literal>a-node</literal>)
	      that have the same value of the attribute
	      <literal>afun</literal>
	      and the value starts with the substring <literal>Aux</literal>.
	    </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>function</term>
	    <listitem><synopsis>function :: FUNCTION_NAME '(' (expression (',' expression)*)?   ')'</synopsis>
	    <mediaobject id="rail_function">
	      <textobject role="syntax_diagram">
		<simpara><![CDATA[ function : FUNCNAME '(' (expression + ',' ) ')' ; ]]></simpara>
	      </textobject>
	      <imageobject>
		<imagedata format="linespecific" fileref="rail_function.pdf"/>
	      </imageobject>
	      <imageobject>
		<imagedata format="PNG" fileref="rail_function.png"/>
	      </imageobject>
	    </mediaobject>
	    <para>
	      Functions are written as function name followed by a comma-separated list of its arguments in brackets.
	      The functions currently supported by PMLTQ are listed in 
	      Section <xref linkend="functions"/>
	      :
	    </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
    </section>
  </section>
  <section id="functions">
      <title>Functions</title>
      <section>
	<title>Functions related to the tree structure</title>
      <variablelist>
	<varlistentry>
	  <term>name($node?)</term>
	  <listitem><para>Return the name of a given node (assume current node if used without an argument).
	  This function only makes sense if the node is an element of a PML sequence
	  (of trees or child nodes).</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>depth($node?)</term>
	  <listitem><para>Returns the depth of a given node in the tree (counting from 0). If no node is given, the current node is assumed.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>descendants($node?)</term>
	  <listitem><para>Returns the number of given node's descendants. If no node is given, the current node is assumed.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>lbrothers($node?)</term>
	  <listitem><para>Returns the number of given node's left brothers. If no node is given, the current node is assumed.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>rbrothers($node?)</term>
	  <listitem><para>Returns the number of given node's right brothers. If no node is given, the current node is assumed.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>sons($node?)</term>
	  <listitem><para>Returns the number of given node's sons. If no node is given, the current node is assumed.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>depth_first_order($node?)</term>
	  <listitem><para>Returns the depth-first order of a given node in the tree (counting from 0). If no node is given, the current node is assumed.</para></listitem>
	</varlistentry>
      </variablelist>	
      </section>
      <section>
	<title>Functions related to corpus</title>
      <variablelist>
	<varlistentry>
	  <term>file($node?)</term>
	  <listitem><para>Returns the filename of a document in which a given node occurrs.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>tree_no($node?)</term>
	  <listitem><para>Returns index of a tree in which a given node occurs,
	  i.e. the position of the tree in its document.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>address($node?)</term>
	  <listitem><para>Returns an URL uniquely determining the given node.
	  The same value can be also computed using the following expression:
	  <literal>file($node) &amp; '##' &amp; tree_no($node) &amp; '.' &amp; depth_first_order($node)</literal>.</para></listitem>
	</varlistentry>
      </variablelist>
      </section>
      <section>
	<title>String functions</title>
      <variablelist>
	<varlistentry>
	  <term>length(string)</term>
	  <listitem><para>Returns the string length of a given expression.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>substr(string,offset,length?)</term>
	  <listitem><para>Returns a substring of a given string starting at at a given offset (first character
	  in the string has offset 0) and spanning for a given length or to the end of the string, 
	  if length is omitted or if the original string has less than offset+length characters.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>match(string,regexp,flags?)</term>
	  <listitem><para>Returns the first substring of a given string 
	  matching a given regular expression.
	  The optional third argument can be a string of flags modifying the behavior of the regular
	  expression matching procedure. The following flags are supported:
	</para>
	  <variablelist>
	    <varlistentry>
	      <term>i</term>
	      <listitem>
		<para>case insensitive match</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>c</term>
	      <listitem>
		<para>case sensitive match (default)</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>n</term>
	      <listitem>
		<para>allows the period (.) to match the newline character</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>m</term>
	      <listitem>
		<para>Treat string as multiple lines.
		That is, change "^" and "$" from matching the start or end of the string to matching the
		start or end of any line anywhere within the string.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>replace(string,substr,replacement)</term>
	  <listitem><para>Substitutes a given replacement for all (non-overlapping) occurrences of a given
	  substring in a given string and returns the result. For example, <literal>replace('banana ananas','ana','ANA')</literal>
	  returns <literal>bANAna ANAnas</literal>.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>substitute(string,regexp,replacement,flags?)</term>
	  <listitem><para>Substitutes a given replacement for the first or all (non-overlapping) substrings
	  matching a given regular expression in a given string and returns the result. 
	</para>
	<para>
	  The default behavior is to replace just the first matching substring. 
	  To replace all occurrences, use the flag 'g'. 
	</para>
	<para>
	  The replacement string may contain references to subexpressions 
	  of the matching regular expression (subexpressions are parts of the expressions 
	  enclosed in brackets). The string \N, where N is a digit from 1 to 9, is a reference
	  to the N-th subexpression (counting opening brackets from the left),
	  and is substitued in the result by the substring matched by that subexpression.
	  For example, if the regular expression was
	  <literal>a(b(c))(d)</literal>, then 
	  <literal>\1</literal>, <literal>\2</literal>,
	  and <literal>\3</literal> refer
	  to the subexpressions <literal>(b(c))</literal>,
	  <literal>(c)</literal>,
	  and <literal>(d)</literal>, respectivelly.
	</para>
	<para>Since backslash (<literal>\</literal>) is used
	to introduce subexpression references in the replacement string,
	literal backslash has to be written as <literal>\\</literal>.
	</para>
	<para>
	  The optional third argument is a string of flags modifying the behavior of the regular
	  expression matching procedure. Any of the flags described above for the
	  function <literal>match()</literal> can be used here, and additionally
	  <literal>substitue()</literal> supports the following flag:
	</para>
	  <variablelist>
	    <varlistentry>
	      <term>g</term>
	      <listitem>
		<para>global replace: replace all non-overlapping matches of a given regular expression</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  <para>
	    For example, <literal>substitue('banana ananas','([^n])a','\1@','g')</literal>
	    returns the string <literal>b@nana @nanas</literal>.
	  </para>
	  </listitem>
	</varlistentry>	
	<varlistentry>
	  <term>lower(string)</term>
	  <listitem><para>Returns lowercase version of a given expression.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>upper(string)</term>
	  <listitem><para>Returns uppercase version of a given expression.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>tr(string,characterss_to_replace,replacement)</term>
	  <listitem><para>Replaces all occurences of given characters in a string with corresponding characters in the replacement set,
	  that is, replaces all occurrences of the Nth character from <replaceable>characters_to_replace</replaceable> with the Nth character
	  in the <replaceable>replacement</replaceable>. For example, <literal>tr('122-34','24','ab')</literal> returns the string 
	  <literal>1aa-b4</literal>.</para></listitem>
	</varlistentry>
      </variablelist>
      </section>
      <section>
	<title>Numeric functions</title>
      <variablelist>
	<varlistentry>
	  <term>ceil(number)</term>
	  <listitem><para>Return the smallest integer value greater than or equal to a given numerical argument.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>floor(number)</term>
	  <listitem><para>Return the largest integer value less than or equal to the numerical argument.</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>round(number,places?)</term>
	  <listitem><para>Returns a given number rounded to a specified number of decimal places (0 if the second argument is not specified).</para></listitem>
	</varlistentry>
	<varlistentry>
	  <term>trunc(number,places?)</term>
	  <listitem><para>Returns a number truncated to a certain number of decimal places (0 if second argument is not specified).</para></listitem>
	</varlistentry>
	<!--
	    <varlistentry>
	    <term>percnt(number,places?)</term>
	    <listitem><para>This is a convenience function, which returns
	    the same value as <literal>round(100*number,places)</literal>.</para></listitem>
	    </varlistentry>
	-->
      </variablelist>
      </section>
  </section>
  <section>
    <title>Examples</title>
    <para></para>
  </section>
  <section>
    <title>Graphical representation in TrEd</title>
    <para>
    </para>
  </section>
  <section>
    <title>TrEd search interface</title>
    <para>
    </para>
  </section>
  <section>
    <title>Web interface</title>
    <para></para>
  </section>
  <section>
    <title>Command-line interface</title>
    <para>
      <!--
      describe 'pmltq' command-line utility,
      describe usage from btred command line
      -->
    </para>
  </section>
  <section>
    <title>BTrEd interface</title>
    <para></para>
  </section>
  <section>
    <title>Installing SQL Server and HTTP Proxy</title>
    <para>
    </para>
  </section>
  <section>
    <title>Tools</title>
    <para></para>
  </section>
</article>